现在常用的IPC：
	管道：使用最简单，必须有血缘关系，内核借助环形队列，使用内核缓冲区实现
	信号：开销最小，速度快
	共享内存映射：无血缘关系可用，速度最快
	本地套接字：最稳定，实现复杂
IPC：
	IPC的服务器和客户总是运行在同一个主机上
可重入编译选项：
	-D_REENTRANT
四个主要领域：
	消息队列(管道、FIFO、消息队列)
	同步(互斥锁、条件变量、读写锁、信号量)
	共享内存区(匿名、有名)
	过程调用(Solatis门、SunRPC)
Posix IPC:
	Posix消息队列  ：可以任何模式打开
	Posix信号量    ：任何操作都需要读写模式
	Posix共享内存区：不能以只写模式打开
System V IPC:
	System V消息队列  ：可以任何模式打开
	System V信号量    ：任何操作都需要读写模式
	System V共享内存区：不能以只写模式打开
获取系统限制：//两个系统函数
	pathconf();
	sysconf();
管道和FIFO(有名管道)
	//都使用read和write进行数据读写
	//内核为管道和FIFO维护一个计数器，可随时调用函数unlink，尽管该函数从文件系统中删除了指定路径的文件，
	//但是先前已经打开的，现在仍在打开着的描述符却不受影响
	//但其他IPC并不存在这样的计数器，例如一端向消息队列写入数据后删除该队列，另一端从队列中读信息，队列可能已经消失了
	管道：
		只能在亲缘进程间使用
		单向数据流，可以多读多写
		可创建两个管道，以支持双向读写需求
		#include<unistd.h>  //管道维护在内核中
		int pipe(int fd[2]);//读fd[0],写fd[1]
		//管道读写shell
		FILE* popen("命令行命令",const char*type);
		type:r 读命令行的标准输出
		     w 写命令行的标准输入//对标准错误没有处理
		在所有进程都关闭时就消失了。
		情况：
			读：
				1、有数据，无论写端是否关闭，都返回实际数据
				2、无数据，无写端，返回0，类似读到文件尾，读端收到0后应关闭
				3、无数据，有写端，阻塞等待
			写：
				1、无读端，写异常出错，SIGPIPE
				2、有读端，管道满，阻塞等待
				3、有读端，管道未满，返回写入字节数
    FIFO：
        只能在单台主机上使用，同一主机的不同文件系统也不行(例如NFS安装的网络文件系统)
    	单向半双工(要么打开是来读的，要么打开是要写的，不能既读又写)
    	从头端读数据，在尾端写数据//调用lseek，返回ESPIPE错误
    	int mkfifo(const char* pathname,mode_t mode);
    	mode隐含O_CREATE|O_EXEC//要么创建新的，要么返回已存在错误
    	如果当前尚且没有任何进程打开某个FIFO来写，那么打开这个FIFO来读就会一直阻塞
    	没有读，去写，内核会产生一个SIGPIPE，默认行为就是终止该进程，如果忽略该信号，write会返回一个EPIPE错误
    	//如果向某个没有为读打开的管道写入数据，那么返回SIGPIPE错误
    	可以多写端、多读端，最好单向流动
    	可直接在shell中使用mkfifo命令
    	需要调用unlink才会删除，对应文件系统中的一个文件，非亲缘进程可通信
    一、对于FIFO，需要open去打开FIFO的读端或是写端的描述符。
	1> 如果open的时候没有指定O_NONBLOCK标志，且open的是读端时
		如果不存在此FIFO的已经打开的写端时，open会一直阻塞到有FIFO的写端打开；
		如果已经存在此FIFO的打开的写端时，open会直接成功返回。

	2> 如果open的时候没有指定O_NONBLOCK标志，且open的是写端时
		如果不存在此FIFO的已经打开的读端时，open会一直阻塞到有FIFO的读端打开；
		如果已经存在此FIFO的打开的读端时，open会直接成功返回。

	二、从FIFO或者空管道读写
	1> read时，读端fd没有指定O_NONBLOCK标志
		如果存在此FIFO或管道的已经打开的写端时，阻塞到FIFO或管道中有数据或者FIFO或管道的已经打开的写端全部被关闭为止。
		如果不存在此FIFO或管道的已经打开的写端(已close)时，read返回0；
	2> write时, 写端fd没有指定O_NONBLOCK标志
		如果存在此fifo或管道的已经打开(已经open还未read)的读端时，写入数据
		如果不存在此FIFO或管道的已经打开的写端(已close)时，write报错SIGPIPE
消息队列：
	区别：
		Posix消息队列读总是返回最高优先级的最早消息(取消息指定优先级没有用)，System V可返回任意指定优先级的消息
		当向空的Posix消息队列放入消息时允许产生一个信息或启动一个线程，System V无此机制
	相同：
		有边界
	至少随内核，但如果是通过内存映射文件实现的，那么随文件系统，但这不是必须的。
	当一个消息队列的引用计数大于0的时候就可以删除这个名字，但该消息队列的析构要等到最后一个mq_close发生时才进行。
共享内存：//posix
	void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
	参数：
		addr：  指定映射区的地址，一般为NULL，由内核分配
		length：指定映射区的大小,一般小于等于文件的大小，通常就是文件大小
		port：  设置读写属性，PORT_READ、PORT_WRITE
		flags： 标注共享属性，MAP_SHARED、MAP_PRIVATE(读写内存映射区不会反映到磁盘上)
		fd：    用于共享内存映射区的那个文件的文件描述符
		offset：默认0标识映射文件全部。偏移位置需要是4K的整数倍（MMU最小单位4K）//MMU：内存分页管理单元
	返回值：
		成功：返回映射区的首地址
		失败：MAP_FAILED {(void*)-1}，设置erron
	错误情况:
		文件大小为0，指定len=0,则报错参数无效
		文件大小为0，指定len>0，则报错总线错误SIGBUS
		offset超出文件大小，报错无效参数
		fd打开时只读不行，除非不是空文件，否则扩展文件大小需要写权限
		fd打开时只写不行，因为创建映射区时需要读权限
		创建映射区需要读权限，共享mmap的读写权限，应该<=文件的open权限//即mmap只写是不行的
		fd在mmap创建映射区完成，即可关闭，后续访问映射区，使用指针
		偏移位置需要是4K的整数倍，否则报错参数无效。
		申请的映射区内存可以越界访问，但可能报错，并且超出部分不受保护
	多进程共享：
		mmap对同一个文件创建的映射区是一块//前提：flags=MAP_SHARED，非匿名映射
	匿名映射区：
		mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0);
		//指定MAP_ANONYMOUS时，len随便指定，fd=-1，即可，称之为匿名映射。只能用于血缘进程通信
信号：
	产生：
		1、按键产生，crtl+c,crtl+\,crtl+z
		2、系统调用产生，kill、raise、abort
		3、软件条件产生，定时器
		4、硬件异常，非法访问内存，内存对齐出错(总线错误)
		5、shell命令，kill命令
	信号递达：
		内核将信号发送并到达指定进程
	信号未决：
		信号在产生和递达之间的状态//主要由于阻塞或屏蔽
	处理信号：
		每一个信号都有默认处理方式
			1、忽略(接收并丢弃)
			2、捕捉
			3、执行默认动作
	阻塞信号集(信号屏蔽字)：//处于PCB进程控制块
		将某些信号加入该集合，对他们设置屏蔽，当屏蔽后，再收到该信号，该信号的处理将推后(解除屏蔽字)
	未决信号集：//处于PCB进程控制块
		1、信号产生，该信号的位立刻翻转为1，表示信号处于未决状态，当信号被处理对应位反转回为0
		2、信号产生后由于某些原因(阻塞)不能抵达指定进程，在屏蔽解除前，信号一直处于未决状态。
	SIGKILL、SIGSTOP：
		这俩个信号不能被忽略、处理和阻塞，前者默认终止进程、后者暂停进程
	SIGUSR1、SIGUSR2：
		事件(即发送条件)用于用户自定义，默认动作为终止进程。
	SIGCHLD：
		用于在子进程结束后给父进程发送通知，唯一一个默认动作为忽略的信号。
		产生事件：
			子进程终止时
			子进程接收到SIGSTOP信号暂停时
			子进程暂停态，接收到SIGCONT后唤醒时
	SIGHUP：
		用户退出shell时，向所有由此shell打开的进程发送该信号，默认终止进程。
	kill函数：
		int kill(pid_t pid,int sig);
		pid>0:发送信号给指定进程
		pid=0：发送信号给 与调用kill的进程属于同一个进程组的进程
		pid=-1:发送给进程有权限发送的系统中的所有进程
		pid<-1:发送给进程组id等于pid绝对值的进程
	raise()、alarm()、abort()、settimer()
		都可发送进程//每个进程只有一个定时器
	int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);
		which:
			1、自然定时：           ITIMER_READ    相当于alarm()发送SIGALRM信号
			2、用户空间计时：       ITIMER_VIRTUAL 只计算进程占用cpu的时间，发送SIGVALRM信号
			3、内核+用户空间计时：  ITIMER_PROF     计算占用cpu以及执行系统调用的时间，SIGPROF
		new_value:
			两个结构体参数，一个指定定时时间，另一个指定间隔时间，并且循环使用。
		old_value:
			用来存储到下一次定时时间的剩余时间
系统调用：
	1、慢速，read、write、
	2、其他
	sigaction.sa_flags 可以设置系通过调用被中断后是否重启
会话：
	1、创建会话的进程不能是进程组组长(否则报错返回)，创建会话后该进程成为新会话的首进程
	2、创建会话后该进程成为新会话的组长进程
	3、需要有root权限
	4、新会话丢弃原有的终端，新会话没有终端
	5、建立新会话，先调用fork，父进程退出，子进程调用setsid函数。
守护进程：
	1、创建子进程，父进程退出
	2、调用setsid,摆脱控制终端
	3、改变当前目录位置(防止在可拆卸设备上执行后拔出)
	4、重设权限掩码umask
	5、关闭继承的文件描述符
	6、







