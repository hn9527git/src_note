当参数是指针和引用的时候，可以将是否const当作重载//因为影响到函数是否可以修改实参

函数的返回类型和缺省值不足以区分两个重载函数
	如果在两个函数的参数表中 只有缺省实参的缺省值不同 则第二个声明被视为第一个的重复声明 

当参数类型是 const 或 volatile 时 在识别函数声明是否相同时 并不考虑 const 和volatile 修饰符 .
	但是 如果把 const 或 volatile 应用在指针或引用参数指向的类型上 则在判断函数声明是否相同时 
	就要考虑 const 和 volatile 修饰符//
	// 声明了不同的函数
		void f( int* );
		void f( const int* );
	// 也声明了不同的函数
		void f( int& );
		void f( const int& );

在类中定义的成员函数会被当作是内联函数

在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用；
	在函数体内定义的static表示只在该函数体内有效；

泛型算法接受一对迭代器，还可以接受内置数组的指针对，标记了要遍历的元素的范围，<algorithm>

c_str()返回const char* 指针指向c风格数组：为了防止字符数组被程序直接处理！！！
	//如果返回char*，而这个属性是类的私有属性，那么就可以通过指针直接修改类的私有属性，多么可怕！！！

枚举不能执行迭代，即++和--

容器的元素被初始化为与其类型相关的缺省值 算术和指针类型的缺省值是 0 对于class 类型 
	缺省值可通过调用这类的缺省构造函数获得，也可自己指定

复数complex< double > conjugate[ 2 ] = {
										complex< double >( 2, 3 ),
										complex< double >( 2, -3 )
									};
									complex_obj.real();  ==  real(complex_obj);
									complex_obj.imag();  ==  imag(complex_obj);

typedef 定义以关键字 typedef 开始 后面是数据类型和标识符。

对类的成员函数题的决议发生在类的生命结束之后，即发现类的右大括号。

对类的成员函数的参数列表则在遇到时就适当地决议，所以C++ primer中说到：
	要想在类中使用(重新定义)其本身声明前就已经定义的类型，必须将其放在类的开始处
	//反正放在要用到的地方的上边，而不能像数据成员一样可以放在使用它的成员函数的后面！

pair类：#include<utility> 

在类体外定义的内联成员函数 应该被包含在含有该类定义的头文件中
	//也就是说，内联函数要么写在定义时，要么写在头文件中 

bitset<32> b1   
		转换为字符串：to_string()     
		转换为无符号长整型：to_ulong()

对于 multimap 或 multiset  不支持下标操作是访问 multimap 元素的一个限制
	一种迭代策略是联合使用由 find()返回的 iterator 指向第一个实例 和由 count()返回的值，
	更精彩的策略是使用由 multiset 和 multimap 的特殊操作 equal_range()返回的 iterator 对值
	如果这个值存在 则第一个 iterator 指向该值的第一个实例 且第二个 iterator 指向这个值的
	最后实例的下一位置 如果最后的实例是 multiset 的末元素 则第二个 iterator 等于 end()
	typedef multimap< string,string >::iterator iterator;
	pair< iterator, iterator > pos;
	// pos.first 指向第一个出现
	// pos.second 指向值不再出现的位置
	pos = authors.equal_range( search_item );
	for ( ; pos.first != pos.second; pos.first++ )
	// 对每个元素进行操作

栈，缺省使用deque双端队列实现，也可以显式提供顺序容器作为第二个参数  例如 stack<int,list<int>> intStack;

将参数声明为数组的引用 当参数是一个数组类型的引用时 数组长度成为参数和实参类型的一部分 
	编译器检查数组实参的长度与在函数参数类型中指定的长度是否匹配
	// 参数为 10 个 int 的数组
	// parameter is a reference to an array of 10 ints
	void putValues( int (&arr)[10] );
	int main() {
		int i, j[ 2 ];
		putValues( i ); // 错误: 实参不是 10 个 int 的数组
		putValues( j ); // 错误: 实参不是 10 个 int 的数组
		return 0;
	}

在某些情况下 编译器自动将按值返回转换到按引用返回 该优化被称为命名返回值优化 named return value optimization 

将取地址操作符作用在函数名上也能产生指向该函数类型的指针 因此 lexicoCompare和&lexioCompare 类型相同 指向函数的指针可如下被初始化：
	int (*pfi1)( const string &, const string & ) = lexicoCompare;
	int (*pfi2)( const string &, const string & ) = &lexicoCompare;
	因为不带下标操作符的数组名会被解释成指向首元素的指针，！当一个函数名没有被调用操作符修饰时 会被解释成指向该类型函数的指针！。
	在指向函数类型的指针之间不存在隐式类型转换。

指向函数的指针可以被用来调用它所指向的函数 调用函数时 不需要解引用操作符无论是用函数名直接调用函数 
	还是用指针间接调用函数 两者的写法是一样的 。
	int min( int, int );//函数声明可以不带参数名，有类型就行
	int (*pf)( int, int ) = min;
	调用：
		min(1,2);
		pf(1,2);
		(*pf)(1,2);

指向 C 函数的指针不能用指向 C++函数的指针初始化或赋值 反之亦然 否则 就会产生编译错误 
	再次说明 在 C 函数指针与 C++函数指针有相同特性的编译器实现中 编译器可能会支持一种语言扩展 允许向 f1()传递一个
	 C++函数指针作为实参

new 表达式的操作序列如下 从空闲存储区分配空间 然后用括号内的值初始化该对象 
	从空闲存储区分配对象 new表达式调用库操作符 new() 例： new MyClass;//调用new()先在堆上申请空间，然后再空间上构造类对象

如果指针操作数被设置为 0 则 C++会保证 delete 表达式不会调用操作符delete() 没有必要测试其是否为 0 实际上 在多数实现下 
	如果增加了指针的显式测试，那么该测试实际上会被执行两次

在 delete表达式之后 pi 被称作空悬指针 即指向无效内存的指针 空悬指针是程序错误的一个根源它很难被检测到 
	一个比较好的办法是在指针指向的对象被释放后 将该指针设置为 0 这样可以清楚地表明该指针不再指向任何对象

auto_ptr 是 C++标准库提供的类模板 它可以帮助程序员自动管理用 new 表达式动态分配的单个对象 
	不幸的是对用new表达式分配的数组管理(管理动态数组)没有类似的支持 
	我们不能用auto_ptr 存储数组 如果这样做了 结果将是未定义的
	当 auto_ptr 对象的生命期结束时 动态分配的对象被自动释放
	auto_ptr 对象的定义有下列三种形式
	auto_ptr< type_pointed_to > identifier( ptr_allocated_by_new );
	auto_ptr< type_pointed_to > identifier( auto_ptr_of_same_type );
	auto_ptr< type_pointed_to > identifier;
	例如：auto_ptr<int> p(new int(666));

当一个 auto_ptr 对象被用另一个 auto_ptr 对象初始化或赋值时 左边被赋值或初始化的对象就拥有了空闲存储区内底层对象的所有权 
	而右边的 auto_ptr 对象则撤消所有责任 
	声明一个auto_ptr:
		auto_ptr<int> p;//没有指向任何对象，内部置0，如果对其解引用，发生未定义的行为。
		使用p.get()返回底层指针：		int* pi = p.get();//对于普通指针直接测试是否为0即可。//仅仅返回底层指针
		使用p.release()返回底层指针：   int* pa = p.release();//不仅返回底层指针，而且释放所有权。
		可以auto_ptr<int> p2(p.release()),但不能使用get()//否则两个智能指针指向同一个对象！
		定义之后，不能再用new表达式直接赋值：p=new int(666);//error
		使用p.reset()设置底层指针： p.reset(new int(1024));//如果p原来指向一个字符串对象，则先删除。
		在这种情况下 用字符串操作 assign()对原有的字符串对象重新赋值 比删除原有的字符串对象并重新分配第二个字符串对象更为有效
			// 这种情况下 重置的更有效形式
			// 用 string 的 assign() 设置新值
			pstr_auto->assign( "Long-neck" );
		
int (*p)[1024] = new int[4][1024];
	在空闲存储区上分配的数组不能给出初始化值集，应在循环中一个一个地初始化。

动态分配数组的主要好处是 它的第一维不必是常量值 即 在编译时刻不需要知道维数 就像局部域或全局域中的定义所引入的数组的维数一样 
	这意味着我们可以分配符合当前程序所需要大小的内存

const int *pci = new const int(1024);//在空闲存储区创建一个const对象
	1、必须初始化，或有默认构造函数。
	2、返回值必须是指向const的指针。
	即使 delete 表达式的操作数是一个指向 const int 的指针 delete 表达式仍然是有效的，并且使 pci 指向的内存被释放

定位new:  预先分配内存返回首地址char *p = new char[1024];   
	使用定位new在预先分配的内存中创建对象
	int* pi = new(p) int(1024);  
	释放内存  delete [] p;
	不需要对应定位new的delete操作，因为内存释放后，它所包含的任何对象的生命期也就都结束了
	如果类型不定，需要额外定义一个指针，每次使用定位new后，将其向后挪相应的空间大小
	如果仅为了指定的类或其他类型使用定位new，可以使用链表来分割预先分配的内存池，每次取一个

未命名的名字空间：未命名的名字空间的定义局部于一个特定的文件 不能跨越多个文本文件
	作用：声明局部于某个文件的实体
	未命名名字空间的成员与被声明为 static 的全局实体具有类似的特性。在 C 中 被声明为 static 
		的全局实体在声明它的文件之外是不可见的 。

名字空间别名：namespace IBM = International_Business_Machines;
	using 声明可以出现在全局域和任意名字空间中 同时它也可以出现在局部域中

链接指示符只能指定重载函数集中的一个函数
	// 错误: 在一个重载函数集中有两个 extern "C" 函数
	extern "C" void print( const char* );
	extern "C" void print( int );
	每个重载函数都有一个唯一的内部名编码：例如将参数类型和个数编码成函数名的一部分
	这种特殊编码不适用于用链接指示符 extern "C"声明的函数 这就是为什么在重载函数集合中只有一个函数
		可以被声明为 extern "C"的原因 具有不同的参数表的两个 
		extern "C"的函数会被链接编辑器视为同一函数//这就是为什么C语言不支持重载函数的原因

可以抛出枚举类型的异常
	enum EHstate { noErr, zeroOp, negativeOp, severeError };
	int mathFunc( int i ) {
	if ( i == 0 )
	throw zeroOp; // 枚举类型的异常
	// 否则的话 继续正常处理流程

栈展开 stack unwinding 随着栈的展开 在退出的复合语句和函数定义中声明的局部变量的生命期也结束了 C++保证 
	随着栈的展开 尽管局部类对象的生命期是
	因为抛出异常而被结束 但是这些局部类对象的析构函数也会被调用 

未找到处理异常的代码时，默认调用terminate(),terminate()默认调用abort()。//必要时可以修改terminate()函数的实现。

catch(MyClass mc){mc.value=666;throw;}//重新抛出非引用异常对象，在此作用域得修改不影响重新抛出得对象

catch(MyClass &mc){mc.value=666;throw;}//重新抛出引用异常对象，对抛出异常的修改有效

异常规范 exception specification 提供了一种方案 它能够随着函数声明列出该函数可能抛出的异常 它保证该函数不会抛出任何其他类型的异常
	//对于 pop()的调用 保证不会抛出任何 popOnEmpty 类型之外的异常 
	void pop( int &value ) throw(popOnEmpty);//通过声明直接指定本函数可以抛出的异常

如果函数向上(!!!)抛出了一个没有被列在其异常规范中的异常 则系统调用 C++标准库中定义的函数unexpected()，
	unexpected()的缺省行为是调用 terminate() 

如果函数抛出了一个没有被列在其异常规范中的异常 系统未必就会调用 unexpected() 如果该函数自己处理该异常 
	并且该异常在 逃离 该函数之前被处理掉 那么一切都不会有问题 

extern void no_problem() throw();//保证不会抛出异常
	如果一个函数声明没有指定异常规范 则该函数可以抛出任何类型的异常
	在被抛出的异常类型与异常规范中指定的类型之间不允许类型转换 

由于内联函数必须在调用它的每个文本文件中被定义 所以没有在类体中定义的内联成员函数必须被放在类定义出现的头文件中 

函数指针的主要性能缺点是 它的间接引用使其不能被内联。
	//自我理解：函数指针是运行时才知道具体值得变量，所以不能内联
	//或者整一个const函数指针，但这样函数指针又没有了意义，函数指针得意义就在于动态地调用函数
	//又或者编译器被设计为不内联函数指针，尽管它是个const指针。
	对函数指针的替代策略是函数对象：函数对象是一个类 它重载了函数调用操作符 operator() 
	函数对象与函数指针相比较 有两个方面的优点 :
	首先 如果被重载的调用操作符是 inline函数 则编译器能够执行内联编译 提供可能的性能好处 
	其次 函数对象可以拥有任意数目的额外数据(对象的属性) 用这些数据可以缓冲结果 也可以缓冲有助于当前操作的数据

函数适配器：
	绑定器：为需要两个参数的函数的一个参数指定值，bind2nd，bind1st
		例1：count_if(v1.begin(),v1.end(),bind1st(less<int>(),4));
		例2：count_if(v1.begin(),v1.end(),bind2nd(less<int>(),4));
	取反器：将函数的判定结果取反
		not1：反转一元函数对象的真值
			例子：count_if( vec.begin(), vec.end(),not1(less_equal(10)) );//结果是大于10的值
		not2：not2 翻转二元谓词函数的真值

友元声明不受三种成员访问限定符的限制
	一个友元或许是一个名字空间函数 另一个前面定义的类的一个成员函数 也可能是一个完整的类 
	在使一个类成为友元时 友元类的所有成员函数都被给予访问 被授权友谊的类访问自己非公有成员 的权力 
	类必须将重载函数集中每一个希望设为友元的函数都声明为友元

引用的大小：
	在类和结构体里，引用和指针的大小是一样的。
	对于基本类型，引用的大小就是所引用的对象的大小。

只有被声明为 const 的成员函数才能被一个 const 类对象调用 关键字 const 被放在成员函数的参数表和函数体之间 
	对于在类体之外定义的 const 成员函数 ,我们必须在它的定义和声明中同时指定关键字 const 
	把一个成员函数声明为 const 可以保证这个成员函数不修改类的数据成员但是 如果该类含有指针 那么在 const 
		成员函数中就能修改指针所指的对象,编译器不会把这种修改检测为错误
	const 成员函数可以被相同参数表的非 const 成员函数重载 在这种情况下 类对象的常量性决定了调用哪个函数。
		构造函数和析构函数是两个例外,即使构造函数和析构函数不是 const 成员函数 const类对象也可以调用它们。

为了允许修改一个类的数据成员 即使它是一个 const 对象的数据成员 我们也可以把该数据成员声明为 mutable 易变的 
	mutable 数据成员永远不会是 const 成员 即使它是
	一个 const 对象的数据成员 mutable 成员总可以被更新 即使是在一个 const 成员函数中

如同类成员函数的定义可以引用类的私有成员一样 静态数据成员的定义也可以 
	例如：static const int MyClass::nameArray[nameSize]="wocao";//nameArray和nameSize属于MyClass的私有数据成员

静态数据成员的类型可以是其所属类 而非static 数据成员只能被声明为该类的对象的指针或引用!!!
	静态数据成员可以被作为类成员函数的缺省实参 而非 static 成员不能
	类外定义静态成员时，不能再加static//出现在类体外的静态成员定义，不能再加static

函数指针不能被赋值为成员函数的地址 即使返回类型和参数表完全匹配 函数指针存储函数的地址 可以被用来直接调用那个函数
	成员函数指针首先必须被绑定在一个对象或者一个指针上 才能得到被调用对象的 this 指针
	然后才调用指针所指的成员函数 

在数据成员指针和普通指针之间的不匹配也是由于这两种指针的表示上的区别 普通指针含有引用一个对象所需的全部信息 
	数据成员指针在被用来访问数据成员之前 必须先被绑定到一个对象或指针上 

union  一种节省空间的类
	可以使用三种访问限定符
	union 不能有静态数据成员或是引用成员 如果一个类类型定义了构造函数 析构函数或拷贝赋值操作符 则它不能成为 union 的成员类型 
	可以为 union 定义成员函数 包括构造函数和析构函数
	为了防止对union的错误访问，一般定义一个额外的判别式来追踪被存储在union中的值的类型。

嵌套类的名字在其外围类域中是可见的 但是在其他类域或名字空间中是不可见的 这意味着 嵌套类的名字不会与外围域中声明的相同名字冲突 

私有成员是指这样的成员 它只能在该类的成员或友元定义中被访问 除非外围类被声明为嵌套类的友元 否则它没有权利访问嵌套类的私有成员 
	外围类要想直接访问嵌套类的私有成员，需要嵌套类将其声明为自己的友元类
	嵌套类也没有任何特权访问其外围类的私有成员 

嵌套类不能直接访问其外围类的非静态成员 即使这些成员是公有的 任何对外围类的非静态成员的访问都要求通过外围类的指针 引用或对象来完成 

嵌套类可以直接访问外围类的静态成员 类型名 枚举值 假定这些成员是公有的 类型名是一个typedef 名字 枚举类型名 或是一个类名 

枚举值可以在定义枚举的域内被直接访问 为什么 因为枚举定义并不像类定义一样维护了自己相关的域

类也可以定义在函数体内 这样的类被称为局部类 local class 局部类只在定义它的局部域内可见 与嵌套类不同的是 
	在定义该类的局部域外没有语法能够引用局部类的成员 因此 局部类的成员函数必须被定义在类定义中 
	因为没有语法能够在名字空间域内定义局部类的成员 所以也不允许局部类声明静态数据成员//c++11?

同嵌套类一样 局部类可以访问的外围域中的名字也是有限的 局部类只能访问在外围局部域中定义的类型名 静态变量以及枚举值 以及全局对象

如果一个类的成员是公有的，可以直接使用从C语言继承来的机制显式初始化表进行初始化 
	class Data{public:int ival;char *ptr};
	根据数据成员被声明的顺序 这些值按位置被解析//Data d1(666,'s');

缺省情况下 单参数构造函数(或者有多个参数 除了第一个参数外 其他都有缺省实参)被用作转换操作符 
	// 在某个头文件中
	extern void print( const Account &acct );
	// ...
	int main()
	{
		// 把 "oops" 转换成一个 Account 对象
		// 用 Account::Account( "oops", 0.0 )
		print( "oops" );
		// ...
	}
	无意的隐式类转换 如把 oops 转换成一个 Account 对象 已经被证明是很难跟踪的错误
	源 关键字 explicit 被引入到标准 C++中 以帮助我们抑制这种不受欢迎的编译器辅助行为
	explicit 修饰符通知编译器不要提供隐式转换
	class Account{public: explicit Account( const char*, double=0.0 );...};

缺省构造函数是指不需要用户指定实参就能够被调用的构造函数 这并不意味着它不能接受实参 只意味着构造函数的每个参数
	都有一个缺省值与之关联

对于基本类型，除了const和引用(必须使用初始化表)，使用成员初始化表和在构造函数内部初始化在结果和性能上都是等价的。

C++要求 赋值 = 下标 [] 调用 () 和成员访问箭头 -> 操作符必须被定义为类成员操作符 任何把这些操作符定义为名字空间成员的定义
	都会被标记为编译时刻错误 

类重载了+运算符，还需要重载+=运算符，才能使用+=

如果一个类提供了两个分别被称为操作符 new()和操作符 delete()的成员函数 那么它就可以承接自己的内存管理权
	如果在类中定义了这些成员操作符 则它们会被调用 以取代全局操作符来分配和释放该类类型的对象 
	例：当 new 表达式创建一个类类型的对象时 编译器查看该类是否有一个成员操作符 new()
	如果有 则选择这个操作符为该类对象分配内存 否则 调用全局操作符 new() 例如 下面的 new 表达式
		Screen *ps = new Screen;

类成员操作符 new()和 delete()默认都是类的静态 static 成员 它们遵从静态成员函数的一般限制这些操作符被自动做成静态成员函数
 	而无需程序员显式地把它们声明为静态的 尤其要记住的是静态成员函数没有 this 指针 因此它们只能访问静态数据成员
 	其原因是： 这些操作符被调用的时候 要么是在该类对象被创建之前 操作符 new() 要么是在其被销毁之后 操作符 delete()

类成员操作符 new()和 delete()的返回类型必须是void*  //成员数组new和delete的返回类型也必须是void*
	1、类成员操作符 new()的返回类型必须是 void*型 并且有一个 size_t 类型的参数     //
	2、类成员操作符 delete()的返回类型必须是 void 并且第一个参数的类型是 void*     //
		为一个类类型而定义的 delete()操作符 如果它是被 delete 表达式调用的 则它可以有两个参数而不是一个 
		第一个参数仍然必须是 void*型 而第二个参数必须是预定义类型 size_t
		如果还存在额外的参数 则它将被编译器用第一个参数所指对象的字节大小自动初始化
		void operator delete( void *, size_t );
	1、类成员操作符new[]()的返回类型必须是 void* 并且第一个参数的类型是 size_t     //void *operator new[]( size_t );
	2、成员操作符 delete[]()的返回类型必须是 void 它的第一个参数必须是 void*类型   //void operator delete[]( void* );
		一个类的操作符 delete[]()也可以有两个参数 第二个参数的类型是预定义类型 size_t
		如果存在额外的参数 则它由编译器自动初始化 其值等于存贮数组所需内存的字节大小
		void operator delete[]( void*, size_t );

只要每个声明都有惟一的参数表 我们也可以重载类的成员操作符 new() 但是任何一个类操作符 new()的第一个参数的类型都必须是 size_t 
	class Screen {
			public:
			void *operator new( size_t );
			void *operator new( size_t, Screen* );
			// ...
		};
		额外的参数可以被 new 表达式中指定的定位实参初始化 例如
		void func( Screen *start ) {
			Screen *ps = new (start) Screen;
			//1 调用类 Screen 的操作符 new(size_t, Screen*)
			//2 接着 调用类 Screen 的缺省构造函数在start处初始化该对象
			//3 然后 用 Screen 对象的地址初始化 ps
		}
		//如果 Screen 类的缺省构造函数抛出一个异常并退出 则编译器会在 Screen 类的域中查找一个操作符 delete() 
			要想使操作符 delete()被考虑 它必须具有与被调用的 new()操作符的参数类型相匹配的参数 
		//如果说操作符 new()分配了内存 则应该提供相应操作符 delete() 以便当 new 表达式调用的构造函数抛出异常时可以正确地释放内存
			如果定位操作符 new()没有分配内存 则无需提供相匹配的操作符 delete()来释放内存

自定义类的转换：例
	类成员转换函数：operator int() { return value; }
	//在转换函数的声明中 关键字 operator 后面的名字不一定必须是内置类型的名字 
	当使用  c=MyClass+3.14时，自动运用转换将其转换为int 3，再提升为3.0与3.14相加得到double类型值6.14
	转换函数采用如下的一般形式
	operator type();
	这里的 type 可用内置类型 类类型或 typedef 名取代 但是不允许 type 表示数组或函数
	类型 转换函数必须是成员函数 它的声明不能指定返回类型和参数表 

为防止使用该构造函数进行隐式类型转换 我们可以把它声明为显式的explicit
	但是 该构造函数仍然可以被用来执行类型转换 只要程序以强制转换的形式显式地要求转换即可//func( static_cast< Number >( si ) );

函数对象和函数指针的对比：
（1）函数对象有自己的状态，即它可以携带自己的成员函数，而且这个函数对象在多次调用的过程中它的那些状态是共享的，
而函数则不能做到这点（除非定义函数内部的静态变量或者全局变量）。

（2）函数对象有自己的类型，而普通函数则没有。在使用STL的容器时可以将函数对象的类型传递给容器作为参数来实例化相应的模板，
从而来定制自己的算法，如排序算法。//即写一个模板函数对象类。

（3）可以用（而且提倡、建议）函数对象来代替函数指针  。函数对象可以在内部修改而不用改动外部接口

    （1）函数对象通过重载()实现，那么将operator()函数设置为内联函数，可以提高程序的运行速度。如上面的例子，
    	相比于传入greaterNum函数指针为sort的第三个形参，传入是GreaterNum<int>函数子时，程序运行的速度快。
    	因为内联函数在编译时展开，而函数指针要进行调用。
    （2）函数对象可以携带附加信息，如类的其他数据成员，而函数指针则做不到。

cin的get()函数有三种形式
	1、cin.get(char &ch);//从输入流中提取一个字符，包括空白符，存在ch中,返回istream对象
	2、cin.get();//他返回该字符值，而不是istream对象，返回int，而不是char，文件为标志为-1
		//while((i=cin.get()) && i!=EOF)
	3、get(char *sink, streamsize size, char delimiter='\n')
		sink 代表一个字符数组 用来存放被读取到的字符 size 代表可以从 istream 中读入的字
		符的最大数目 delimiter 表示 如果遇到它就结束读取字符的动作 delimiter 字符本身不会
		被读入 而是留在 istream 中 作为 istream 的下一个字符 一种常见的错误是 在执行第二
		个 get()之前忘了去掉 delimiter //cin.ignore();

getline( istream &is, string str, char delimiter );
	例：char c[6];
		cin.getline(c,3,'\n');//第三个参数为结束符，默认为换行

重载输出输入操作符：
	friend ostream& operator<<(ostream&, const WordCount&);
		//参数和返回值都是引用！！！，ostream不允许创建对象，也不允许复制对象
	friend istream& operator>>( istream&, WordCount& );
		//参数和返回值都是引用！！！，istream不允许创建对象，也不允许复制对象

输入输出到文件
	ofstream outfile( "copy.out", ios_base::out );
		//默认为输出模式out，可以改为附加模式app
	ifstream infile( "alice_emma" );
		//使用流迭代器
		istream_iterator<string> ifile( infile );
		istream_iterator<string> eos;
		vector< string > text;
		copy( ifile, eos, inserter( text, text.begin() ));
		ostream_iterator<string> ofile( infile );
		copy(ifile, eos, ofile);




















