三次握手和四次挥手过程·························https://blog.csdn.net/qq_38950316/article/details/81087809
为什么需要三次握手和四次挥手
为什么要有TIME_WAIT这个状态？
	假设最终的ACK丢失，主机2将重发FIN，主机1必须维护TCP状态信息以便可以重发最终的ACK，
	否则会发送RST，结果主机2认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，
	主机1必须进入 TIME_WAIT 状态，因为主机1可能面 临重发最终ACK的情形。
冒泡排序----稳定------------------------https://www.cnblogs.com/hokky/p/8529042.html
选择排序----不稳定
	1.从待排序序列中，找到关键字最小的元素；
	2.如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；
	3.从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。
插入排序----稳定
	直接插入排序
	折半插入排序
	希尔排序
	将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，
	则交换，直到全部元素都比较过。
希尔排序----不稳定
	将待排序数组按照步长进行分组，然后将每组的元素利用直接插入排序的方法进行排序；
	每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。
快速排序----不稳定
	挖坑填数+分治法
    从序列当中选择一个基准数(pivot)
    在这里我们选择序列当中第一个数最为基准数
    将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧
    重复步骤1.2，直到所有子集当中只有一个元素为止。
归并排序----稳定
	将已有的子序列合并，达到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
基数排序----稳定
	通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。
	分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中
	收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]
	对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束
设计模式：
	单例--------------------------------
		特点是只提供唯一一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例;
	简单工厂----------------------------https://www.cnblogs.com/jostree/p/4251756.html
		所谓简单工厂模式，是一种实例化对象的方式，只要输入需要实例化对象的名字，
		就可以通过工厂对象的相应工厂函数来制造你需要的对象。
模态和非模态
纯虚函数
死锁
	原因：互斥性、持有、不可剥夺、环形等待
	互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。
				此时若有其他进程请求该资源，则请求进程只能等待。
	保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，
				此时请求进程被阻塞，但对自己已获得的资源保持不放。 
	不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，
				即只能 由获得该资源的进程自己来释放（只能是主动释放)。 
	循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。
	解决：预防，结束返错，设置超时结束
重载、覆盖、重定义
	1 成员函数重载特征：
	   a 相同的范围（在同一个类中）
	   b 函数名字相同
	   c 参数不同
	   d virtual关键字可有可无
	2 重写（覆盖)是指派生类函数覆盖基类函数，特征是：
	   a 不同的范围，分别位于基类和派生类中
	   b 函数的名字相同
	   c 参数相同
	   d 基类函数必须有virtual关键字
	3 重定义(隐藏)是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
	   a 如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏。
	   b 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有vitual关键字，此时，基类的函数被隐藏。
		const修饰得类成员函数也可作为重载，返回值不行。
数组和链表的区别
多态机制
new delete和malloc free区别
	1）malloc对开辟的空间大小严格指定，而new只需要对象名
	2）new为对象分配空间时，调用对象的构造函数，delete调用对象的析构函数
既然有了malloc/free，C++中为什么还需要new/delete呢？
	因为malloc/free是库函数而不是运算符，不能把执行构造函数和析构函数的功能强加于malloc/free
函数和运算符的区别：
	运算符本质上也是函数，只是运算符需要编译器进一步解释，函数是直接调用
虚函数机制
	无虚函数的类没有虚函数表
生成可执行文件的过程 预处理-编译-汇编-链接
进程间通信方式
	管道，信号量，消息队列，共享内存
epoll和select函数的区别
	都是为了I/O复用，select函数检测的文件描述符需要频繁的拷贝，循环处理，开销大
	epoll函数没有频繁得拷贝，只需要设置一次，返回得是需要的文件描述符，无需遍历
STL:
	包括容器和算法
#define和const、typdef的区别
	define预处理指令，只是简单替换，没有类型检查
	const有对应得数据类型，要进行检查，避免一些低级错误
	typdef是关键字，编译时处理，使程序书写简单，意义明确，增强可读性
堆和栈的区别
	1）栈 stack 存放函数的参数值、局部变量，由编译器自动分配释放
	堆heap，是由new分配的内存块，由应用程序控制，需要程序员手动利用delete释放，如果没有，程序结束后，操作系统自动回收
	2）因为堆的分配需要使用频繁的new/delete，造成内存空间的不连续，会有大量的碎片
	3）堆的生长空间向上，地址越大，栈的生长空间向下，地址越小
内存管理：
	栈：存放函数的参数和局部变量，由编译器自动分配和释放
	堆：由malloc分配的内存，free释放
内存五大区：
	堆栈
	全局区（静态区）--初始化和未初始化分开放
	文字常量区：常量存在这里
	程序代码区：二进制代码只读
内存泄漏以及解决办法
	动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。
	方法：malloc/free要配套，对指针赋值的时候应该注意被赋值的指针是否需要释放；使用的时候记得指针的长度，防止越界
深拷贝和浅拷贝：
	有没有重新分配资源
四种强制转换：
	static_cast:编译器静态类型检查
	dynamic_cast:运行时检查RTTI 基类引用|指针转换为派生类指针|引用
	const_cast:去除const属性
	reinterpret_cast:为了将一种数据结构转换为另一种数据结构
extern "C"
	指示编译器下边的代码按照C语言的方式进行编译
volatile
	指定编译器不做优化，每次到内存中取数据，而不是寄存器中
野指针：
	指向内存被释放的内存或者指向没有访问权限的内存的指针
	与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少
	成因：
		指针变量没有初始化
		指针指向的内存被释放了，但是指针没有置为NULL
		指针超过了变量的安全范围 b[10],(b+11)
栈溢出以及解决办法
	局部变量太多或太大，递归太深
	可以加个static变成静态变量使用全局静态区，或是申请动态空间
进程和线程的区别以及为什么要有进程
	https://www.cnblogs.com/zhuzhu2016/p/5804875.html
	线程进程的区别体现在4个方面：
	第一：因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，
		建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，
		而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，
		比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，
		也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，
		而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。
	第二：体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，
		消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。
	第三：体现在CPU系统上面，线程使得CPU系统更加有效，因为操作系统会保证当线程数不大于CPU数目时，
		不同的线程运行于不同的CPU上。
	第四：体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，
		使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，
		所以线程对程序结构的改善有很大帮助。
进程与线程的选择取决以下几点：
	1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。
	2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应
	3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；
	4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求；
	5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。
进程间通信方式：
	管道、信号量、消息队列、共享内存、套接字
线程通信方式：
	全局变量、消息机制
-----------------------------------------数据库--------------------------------------------------------------------
事务ACID：
	原子性、一致性、隔离性、持久性
死锁：
	多个事务互相想访问对方的锁定的资源
三范式：
	表中字段不能再分
	满足第一条的情况下表中的非主键字段都依赖于主键字段
	满足第二条的情况下非主键字段必须不传递依赖于主键字段
级联删除|级联更新
	on delete cascade;on update cascade;
什么是游标
	是一种从包括多条数据记录的结果集中每次提取一条记录进行处理的机制
	使用步骤：
	1.定义游标 declare cursor name for select 查询语句 [for [readonly|update]];
	2.打开游标：open cursor
	3.操作数据：fetch ...... current of cursor；
存储过程的优缺点
	1.预编译过的，执行效率高2.存在数据库中，直接调用，减少网络通讯
	3.安全性高，需要权限4.可重复使用
	缺点：移植性差
存储过程与函数的区别
	存储过程实现的过程要复杂一些,而函数的针对性较强;
	存储过程可以有多个返回值,而自定义函数只有一个返回值;
	存储过程一般独立的来执行,而函数往往是作为其他SQL语句的一部分来使用;
存储过程
	delimiter //
	CREATE PROCEDURE proc ()
	BEGIN
    SELECT * FROM student;
	END//
自定义函数
	CREATE FUNCTION NameByZip() RETURNS CHAR(50)
	RETURN (select studentPhone from student where studentName = 'JAMES');
MVCC、以及优点和不足
	MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。
	缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作。
索引的优缺点
视图的优缺点
	视图：虚拟表，具有和物理表相同的功能
主键和外键的区别
	主键在本表中是唯一的、不可唯空的，外键可以重复可以为空；
	外键和另一张表的主键关联，不能创建对应表中不存在的外键。
UNION和UNION ALL的区别
varchar2和varchar的区别
MySQL和Oracle的区别
	1.库函数不同
	2.Oracle是用表空间来管理的，MySQL不是
	3.显示当前表用户改变连接用户显示当前连接用户执行外部脚本不同
	4.分页查询时，MySQL用limit，Oracle用rownum
行转列，列转行
什么是PL/SQL？
truncate与delete的区别
	前者通过释放存储数据的数据页来删除，并且只在日志中记录页的释放
	后者每次删除一行，并且记录，耗费的资源多
	delete table:删除内容不删除定义、不释放空间
	truncate table:删除内容不删除定义、释放空间
	drop table:删除内容和定义、释放空间
oracle闪回技术
修改表结构SQL
	alter table name [add | modify | drop]
oracle创建约束
	constraint
oracle序列
	sequence:-----------------------https://blog.csdn.net/hu_dongyang/article/details/79039737


---------------------Linux--------------------------------------------------------------------
ls	cd	mv	mkdir	at	rmdir	rm	touch	locate	ps	jobs	kill	fd	bg
pwd	cp	cat more	less	reboot	poweroff	ping	grep	mount	tar	ln
chown	chmod	useradd	passwd	whereis	find	wget	df	du		
---------------------TCP/IP-------------------------------------------------------------------
TimeWait的作用：
	1.防止上一次连接中的包，迷路后重新出现，影响新连接
	（经过2MSL后，上一次连接中所有的重复包都会消失）
	2.可靠的关闭TCP连接
	在主动关闭方发送的最后一个ack(fin) ，有可能丢失，这时被动方会重新发
	fin, 如果这时主动方处于CLOSED 状态 ，就会响应rst(异常关闭连接) 而不是ack。所以
	主动方要处于TIME_WAIT 状态，而不能是CLOSED 。
	TIME_WAIT 并不会占用很大资源的，除非受到攻击。
	还有，如果一方send 或recv 超时，就会直接进入CLOSED 状态














		

	