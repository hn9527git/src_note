1、C和C++的特点与区别？
答：（1）C语言特点：
	1.作为一种面向过程的结构化语言，易于调试和维护；
	2.表现能力和处理能力极强，可以直接访问内存的物理地址；
	3.C语言实现了对硬件的编程操作，也适合于应用软件的开发；
	4.C语言还具有效率高，可移植性强等特点。
（2）C++语言特点：
	1.在C语言的基础上进行扩充和完善，使C++兼容了C语言的面向过程特点，又成为了一种面向对象的程序设计语言；
	2.可以使用抽象数据类型进行基于对象的编程；
	3.可以使用多继承、多态进行面向对象的编程；
	4.可以担负起以模版为特征的泛型化编程。
什么是面向对象（OOP）？
	面向对象是一种对现实世界理解和抽象的方法、思想，通过将需求要素转化为对象进行问题处理的一种思想。
面向对象三大特性：
	封装
		为了代码隐藏
	继承
		为了代码重用
	多态
		为了接口重用
菱形继承：
	两个子类继承同一个父类，而又有子类同时继承这两个子类
	为了避免模糊继承，需要使用虚继承
	虚继承可以使得虚基类对于由它直接或间接派生的类来说，拥有一个共同的基类对象实例。避免由于带有歧义
	的组合而产生的问题（如“菱形继承问题”）。其原理是，间接派生类（C）穿透了其父类（上面例子中的A与B），实质上直接继承了虚基类X
构造函数和析构函数能不能是虚函数？
	构造函数不能是虚函数，虚函数的调用需要虚函数表指针，而该指针存放在对象的内容空间中；若构造函数声明为虚函数，那么由于对象还未创建，
		还没有内存空间，更没有虚函数表地址用来调用虚构造函数了，定义为虚函数直接报错。
	析构函数可以为虚函数，而且当要使用基类指针或引用调用子类时，最好将基类的析构函数声明为虚函数，否则可能存在内存泄露的问题。
构造函数中和析构函数中不能调用虚函数：
	语法没有问题，可以正常运行，但是结果不对，
	如果在构造函数或者析构函数中调用虚函数，运行的都将是为构造函数或者析构函数自身类类型定义的虚函数版本。
	就是说派生类在构造时，先构造父类，在父类的构造函数中，当作父类对象，在派生类的构造函数中当作派生类对象，没有动态的效果。
	而且我们所调用的函数可能操作还没有被初始化的成员，这将导致灾难发生。
左值和右值：
	左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；
         右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。
         一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。
    右值引用：使用它可以使临时对象的拷贝具有move语意，从而可以使临时对象的拷贝具有浅拷贝般的效率，这样便可以从一定程度上解决临时对象的
    深度拷贝所带来的效率折损，主要是消除了不必要的额外开销
lambda:
	匿名函数
		优点：使得代码简洁，可以内联，提高效率
		缺点：不好编写理解
http和https的区别？
答：HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。
	HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议，与http主要区别在于：
	#http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议；
	#http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443；
https建立连接详细过程：
	在使用HTTPS是需要保证服务端配置正确了对应的安全证书
	客户端发送请求到服务端
	服务端返回公钥和证书到客户端
	客户端接收后会验证证书的安全性,如果通过则会随机生成一个随机数,用公钥对其加密,发送到服务端
	服务端接受到这个加密后的随机数后会用私钥对其解密得到真正的随机数,随后用这个随机数当做私钥对需要发送的数据进行对称加密
	客户端在接收到加密后的数据使用私钥(即生成的随机值)对数据进行解密并且解析数据呈现结果给客户
	SSL加密建立
TCP、UDP区别和应用：
	TCP、UDP都属于传输层协议
	TCP提供面向连接的可靠的字节流传输服务，UDP提供不可靠的数据报传输服务
	TCP保证连接传输的数据无差错、不丢失、不重复、有顺序，而UDP仅尽最大努力交付，不保证可靠性
	TCP连接为点到点的，UDP支持一对一以及一对多和多对多的传输模式
	TCP的头部比UDP大，而且需要定时器和保存发送的数据缓冲，需要的开销比UDP大
	TCP:
		优点：稳定，数据流量稳定、速度稳定、有顺序
		缺点：传输速度慢、开销大
		使用场景：对数据的完整性要求较高，不追求效率，大数据传输、文件传输
				  FTP、HTTP、SSH
	UDP：
		优点：传输速度快、开销小
		缺点：不稳定、无顺序性
		使用场景：对时效性要求高、稳定性其次，游戏、视频。
虚拟内存的概念与介绍
答：
	虚拟内存基本思想：每个程序有自己的地址空间，这个空间被分割成多个块，每一块称为一个页，每一页有连续的地址范围。这些页被映射到
		物理内存，但并不是所有的页都必须在内存中才能运行程序，当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射
		，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的页装入物理内存并使执行失败的指令。
	虚拟内存的实现有以下三种方式：
		#请求分页存储管理
		#请求分段存储管理
		#请求段页式存储管理
	虚拟内存的意义：
	一，虚拟内存可以使得物理内存更加高效。虚拟内存使用置换方式，需要的页就置换进来，不需要的置换出去，使得内存中只保存了需要的页，
		提高了利用率，也避免了不必要的写入与擦除；
	二，使用虚拟地址可以使内存的管理更加便捷。在程序编译的时候就会生成虚拟地址，该虚拟地址并不是对应一个物理地址，使得也就极大地减少
		了地址被占用的冲突，减少管理难度；
	三，为了安全性的考虑。在使用虚拟地址的时候，暴露给程序员永远都是虚拟地址，而具体的物理地址在哪里，这个只有系统才了解。这样就提
		高了系统的封装性。
拥塞控制相关变量：
	SWND：发送窗口(向网络一次连续写入的数据量)，限定了发送端连续发送的TCP报文数量， = MIN(RWND,CWND)
	SMSS：TCP报文数据段最大长度，其值一般等于MSS
	RWND：接收通告窗口
	CWND：拥塞窗口	
	RTT： (Round-Trip Time)往返时间在计算机网络中它是一个重要的性能指标。表示从发送端发送数据开始，到发送端收到来自接收端的确认
	（接收端收到数据后便立即发送确认，不包含数据传输时间）总共经历的时间。
	MTU:以太网帧最大传输单位，一般为1500字节
慢启动：
	TCP连接建立好之后、CWND被设置为初始值IW(Initial Window),大小为2-4个SMSS，此时发送端只能发送IW大小字节的数据
	此后，每接收到一个ACK确认，其CWND就按照 CWND += MIN(N，SMSS) 增加//N是此次确认中包含的之前未被确认的字节数
	此时CWND按照指数形式扩大，这就是所谓的慢启动
	存在理由：TCP模块刚开始发送数据时不知道网络的实际情况，需要以一种试探的方式平滑地增加CWND的大小
拥塞控制：
	如果不加以其他手段，慢启动必然使得CWND很快膨胀，并最终导致网络拥塞，所以定义了慢启动门限(slow start threshold size,ssthresh)
	当CWND大于该值时，TCP拥塞控制将进入拥塞避免阶段//拥塞控制使得CWND按照线性方式增加，从而减缓其扩大
	两种实现方式：
		1、每个RTT时间内按照 CWND += MIN(N，SMSS) 计算新的CWND，而不论该RTT时间内发送端收到多少个确认
		2、每收到一个对新数据的确认报文段，就按照 CWND+=SMSS*SMSS/CWND 来更新CWND
如何判断拥塞发生：
	1、传输超时、或者说TCP重传定时器溢出
		这种情况下仍使用慢启动和拥塞避免
		执行重传、并调整慢启动门限
		ssthresh = MAX(FlightSize/2,2*SMSS)     CWND<=SMSS
		FlightSize:已经发送但是未收到确认的字节数，调整之后，CWND将小于SMSS，必然小于新的ssthresh，故而拥塞控制再次进入慢启动阶段
	2、接收到重复的确认报文段//如果是定时器溢出之后发生，按第一种处理
		这种情况下使用快速恢复和快速重传//即接收到三个重复的确认报文段，就认为拥塞发生了，启动快速重传和快速恢复
快速重传和快速恢复：
	1、当收到第三个确认报文段时，按照ssthresh = MAX(FlightSize/2,2*SMSS)重设ssthresh，然后立即重传丢失的报文，
	   并设置CWND=ssthresh+3*SMSS
	2、每次收到一个重复的确认时，设置CWND=CWND+SMSS，此时发送端可以发送新的TCP报文段
	3、当收到新数据的确认时，设置CWND=ssthresh//即将拥塞控制恢复到拥塞避免阶段
什么是进程和线程，特点和区别？
	程序加载到内存中执行，此时就是一个进程，进程是操作系统分配资源的最小单位
	线程是进程中的一个实体，一个进程可以有多个线程，线程是操作系统调度的最小单位
	多线程运行在同一个进程的相同的地址空间内，创建和销毁线程的开销比进程少
不使用第三个参数交换两个变量的值
	y = x ^ y;
	x = x ^ y;
	y = x ^ y;
	原理：异或操作，相同为0，不同为1
	      即A^A = 0;A^0 = A;
	      第二步 x = x ^ y = x ^ x ^ y = 0 ^ y = y;//将y赋值给了x
	      第三步 y = x ^ y = y ^ x ^ y = 0 ^ x = x;//将x赋值给了y 
delete时是怎么知道到底有多少个对象的？
	因为new[]的时候会在返回的指针的前一个8个字节的空间中存储数组到底有多少个元素
	delete时只需要根据传入的指针向前取一下这个值就可以了
timewait状态原因：
	可靠地终止TCP连接
	保证让迟来的TCP报文有足够的时间被识别并丢弃
设计模式：
	单例
	简单工厂
	适配器
	代理
	反应堆
	前摄器
	桥接
	领导者/追随者
	观察者
varchar2和varchar的区别
	1.varchar2把所有字符都占两字节处理(一般情况下)，varchar只对汉字和全角等字符占两字节，数字，英文字符等都是一个字节；
	2.VARCHAR2把空串等同于null处理，而varchar仍按照空串处理；
	3.VARCHAR2字符要用几个字节存储，要看数据库使用的字符集，
	大部分情况下建议使用varchar2类型，可以保证更好的兼容性
进程和线程的区别以及为什么要有进程
	线程进程的区别体现在4个方面：
	第一：因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，
		建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，
		而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，
		比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，
		也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，
		而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。
	第二：体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，
		消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。
	第三：体现在CPU系统上面，线程使得CPU系统更加有效，因为操作系统会保证当线程数不大于CPU数目时，
		不同的线程运行于不同的CPU上。
进程与线程的选择取决以下几点：
	1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。
	2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应
	3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；
	4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求；
	5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。
一个C++空类编程默认提供的函数（4个）
	默认构造、默认复制构造、默认赋值运算符重载、默认析构
二叉查找树、平衡二叉查找树AVL、弱平衡红黑树的区别
	二叉查找树：
		定义：左节点<父节点<右节点
	AVL	: 平衡二叉查找树
		是一个二叉查找树，并且每个节点的左子树和右子树的高度最多相差1
		平衡度比红黑树高，适用于查询多，增删少的情况，为了保持平衡可能需要多次旋转
	红黑树：
		1. 每个节点非红即黑
		2. 根节点是黑的;
		3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;
		4. 如果一个节点是红的，那么它的两儿子都是黑的;
		5. 每条路径都包含相同的黑节点;
		适用于查询少，增删多的情况，为了保持平衡比AVL旋转次数少
乐观锁：
	乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：
	如果别人修改了数据则放弃操作，否则执行操作。
悲观锁：
	悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能
	修改数据。
半关闭：
	当TCP链接中A向B发送 FIN 请求关闭，另一端B回应ACK之后，并没有立即发送 FIN 给A,A方处于半连接状态（半开关），
	此时A可以接收B发送的数据，但是A已经不能再向B发送数据。
半连接：
	发生在TCP三次握手中
	如果A向B发起链接，B也按照正常情况响应了，但是A不进行三次握手，这就是半连接。
	半连接攻击：半连接，会造成B分配的内存资源就一直这么耗着，直到资源耗尽。（SYN攻击）
半打开：
	如果一方关闭或者异常关闭（断电，断网），而另一方并不知情，这样的链接称之为半打开。处于半打开的连接，如果双方不进行数据通信，
	是发现不了问题的，只有在通信是才真正的察觉到这个连接已经处于半打开状态，如果双方不传输数据的话，仍处于连接状态的一方就不会检测
	另外一方已经出现异常
	解决方法：引入心跳机制就可以察觉半打开。
	如果需要发数据的话，这边收到之后 其实发现这个连接并不存在了，就会回复RST包告知，这个时候就需要重新建立连接了！
MYSQL五大连接
	全连接：union 连接相同字段的不同结果集
	外连接：	
		左外连接：SELECT * FROM a LEFT OUTER JOIN b ON(a.id = b.id)	//左边全部数据和右边符合条件的
		右外连接：SELECT * FROM a RIGHT OUTER JOIN b ON(a.id = b.id)//右边全部数据和左边符合条件的	
	内连接：	  SELECT * FROM a INNER JOIN b ON(a.id = b.id)      //左右都只要符合条件的
	交叉连接：CROSS JOIN 笛卡尔积，N对N	
惊群效应：
	多进程或多线程服务器下，如果一个监听事件到来，可能会唤醒所有阻塞睡眠在这个事件上的进程或线程，但最终只有一个进程或线程得到这个事件
	的处理权，其他进程或线程重新进入睡眠，造成系统对用户进程/线程频繁地做无效的调度，过多而且无用的上下文切换导致系统性能大打折扣，
	为了确保只有一个线程得到资源，用户必须对资源操作进行加锁保护，进一步加大了系统开销。
map和unorder_map区别：
	内部实现机理不同
	map： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的
	所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树
	进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所
	有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。
	unordered_map: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度
	可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。
	优缺点以及适用处
	map：
	优点：
	有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
	红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高
	缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/
	黑性质，使得每一个节点都占用大量的空间
	适用处：对于那些有顺序要求的问题，用map会更高效一些
	unordered_map：
	优点： 因为内部实现了哈希表，因此其查找速度非常的快
	缺点： 哈希表的建立比较耗费时间
	适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map
	总结：
	内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。
	但是unordered_map执行效率要比map高很多
	对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的
libevent核心原理：
	是一个轻量级的高性能网络库，事件驱动的，使用反应堆模式，
	对三类事件源进行了统一，用event结构体表示，每个event表示一个事件
	同时监听多个事件，使用尾队列(本质是双向链表)和小根堆
	所有事件添加都被插入到已注册事件队列
	事件触发后，被插入激活事件队列
	信号事件添加时会插入信号事件队列
	定时器事件用小根堆管理，堆顶的定时器事件是超时时间最小的
	使用有固定的流程，首先创建一个反应堆event_base，然后添加需要监听事件，设置回调函数，然后循环等待，事件发生时将被激活的事件
	放入激活事件队列中，然后统一调用对应的回调函数处理事件
TCP粘包：
	发送端为了将多个发往接收端的包，更加高效的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，
	合并成一个数据量大的数据块，然后进行封包。那么这样一来，接收端就必须使用高效科学的拆包机制来分辨这些数据。
	解决方法：//使用一个预处理线程进行拆包工作
			  1、可以约定好一个包的开头和结尾字符，但数据中不能出现这个字符
			  2、也可以在发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断
			  	每个分组的开始和结束位置。
			  3、每次发送固定长的的数据，不满足就填上特殊字符区分。
	UDP不会发生粘包，因为每一个UDP数据包都含有头信息。
linux下动态库和静态库：
	本质上为可执行代码的二进制格式，可以被装入内存中执行。
	分为静态库和动态库
	不同：被载入的时刻不同
	静态库在程序编译时被链接到目标代码中，目标程序运行时不再需要该静态库，移植方便但体积大，浪费资源，可执行文件大，但执行速度快
	动态库在程序运行时才被载入，可执行文件小。使得程序升级相对简单，比如动态库更新，只需要更换动态链接库文件，不需要更换可执行文件
LRU算法思想：
	最近最少使用算法
	LRU 算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，
	应当把最久没有被访问到的数据淘汰。
	通过哈希表和双向链表实现：
	 思路：  hash_map  存储数据 ，实现查找效率O(1)，双向链表实现算法逻辑
     算法逻辑： 1.新数据会插入到链表头部
                2.当缓存数据被访问，将该缓存数据移到链表头部
                3.当新数据插入时达到缓存上限了，将尾部数据删除掉（也就是最近最少使用的），新数据放在头部
	最小堆也可实现
KMP算法：
	直接移动模式串，使其公共前缀变成后缀
单链表逆置：
	原地逆置最好
	借助
获得int数组中第二大的数
	设置最大值为max，第二大值初始化为int的最小值sec_max
	循环数组判断每一个值，如果当前值大于最大值就将最大值替换给sec_max，然后最大值设置为当前值
	如果当前值小于最大值，就判断是否大于sec_max，如果是，就将当前值赋值给第二大值
	如此，一次循环即可得到
链表有环的问题
	1.将next指针的值放入set中，判断返回值
	2.两个指针不同速度地跑
static作用：
	全局变量：局限于当前文件
	局部变量：局限于当前文件的这个函数内部使用
	普通静态函数：局限于当前文件
	类内静态函数：不需要对象就可调用
	作用域为声明到程序结束
vector构造对象问题：
	如果仅指定个数，则调用默认构造函数。
	如果指定额外的对象，则调用拷贝构造函数构造
	如果指定额外的构造参数，先调用默认构造函数生成一个临时对象，再一个一个拷贝
	如果将vector赋值给另一个vector，对每一个元素对象调用复制构造函数。
IO复用：
	select优点：
		可以监听多个套接字
		跨平台，几乎每个平台都提供select函数
	select缺点：
	（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
	（2）同时每次调⽤用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大
	（3）select支持的文件描述符数量太少了，默认是1024
	poll优点：
		自带数组结构，减少循环次数，提高效率
		可以将监听事件和返回事件分离
		可以拓展监听上限，超出1024限制
	缺点：
		不能跨平台，只在类UNIX中使用
		无法直接定位满足监听事件的文件描述符，需要循环
	基于select和poll的I/O复用技术速度慢的原因：
		调用select函数后常见的针对所有文件描述符的循环语句
		每次调用select函数时都需要向该函数传递监视对象信息，因为套接字由操作系统管理，用户空间到系统空间的信息传递是主要负担，
		且无法通过代码优化
	epoll优点：
		无需编写以监视状态变化为目的的针对所有文件描述符的循环语句
		调用对应于select函数的epoll_wait函数时无需每次传递监视对象信息
		可以显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU的利用率!!!
		可以突破1024文件描述符
		提供了两种触发模式：边沿触发、水平触发(默认)
	epoll缺点：
		不能跨平台，只支持linux，连unix都不支持
epoll水平和边沿触发优缺点：
	水平优点：当进行socket通信的时候，保证了数据的完整输出，进行IO操作的时候，如果还有数据，就会一直的通知你。
	水平缺点：由于只要还有数据，内核就会不停的从内核空间转到用户空间，所有占用了大量内核资源，内核资源的浪费严重。效率也是很低的。
	边沿优点：每次内核只会通知一次，系统不会充斥大量你不关心的就绪文件描述符，大大减少了内核资源的浪费，提高效率。
			  并且可以分离接受数据和处理数据的时间点
	边沿缺点：不能及时的取出所有的数据，需要循环
time_wait状态：
	1.为实现TCP全双工连接的可靠释放
	    当服务器先关闭连接,如果不在一定时间内维护一个这样的TIME_WAIT状态,那么当被动关闭的一方的FIN到达时，服务器的TCP传输层会用RST包
	    响应对方，这样被对方认为是有错误发生，事实上这只是正常的关闭连接工程，并没有异常
	2.为使过期的数据包在网络因过期而消失
	   在这条连接上,客户端发送了数据给服务器，但是在服务器没有收到数据的时候服务器就断开了连接
		现在数据到了,服务器无法识别这是新连接还是上一条连接要传输的数据,一个处理不当就会导致诡异的情况发生
TCP拥塞控制和流量控制的区别：
	拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或通信链路不致过载。拥塞控制所要做的都有一个前提：
	          网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有
	          因素。
	流量控制：指点对点通信量的控制，是端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收
innodb和myisam区别：
	支持事务		-	不支持事务
	支持外键		-	不支持外键
	支持行锁		-	支持表锁
	写效率高		-	读效率高
	不支持全文本索引-	支持全文本索引
	表占用空间小	-	表占用空间大
	聚簇索引		-	非聚簇索引
聚集索引：
	按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录信息，数据和索引在一起，也将聚集索引的
	叶子节点称为数据页，每个数据叶通过一个双向链表进行链接。
非聚集索引：或称辅助索引
	叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，每个叶子节点中的索引行中还包含了一个书签，用来
	告诉innodb存储引擎在哪找到与索引对应的行数据。
Nosql和Mysql区别：
	存储方式：关系型数据库将数据存储在表的行和列中，容易关联存储，提取方便，而Nosql则相反，是组合在一起，通常存储在数据集中
	存储结构：关系型数据库对应的是结构化数据，数据表需要提前设计定义，修改比较困难。而nosql基于动态结构，使用非结构化数据
			  可以很容易适应数据类型和结构的变化
	存储扩展：关系型数据库是纵向扩展，要想提高处理能力，需要使用速度更快的计算机，而nosql是横向扩展的，天然是分布式存储的。
	查询方式：关系型数据库使用结构化查询语言，nosql查询以块为单元操作数据。
	事务：关系型数据库遵循ACID规则，对事务的支持很好，而nosql是在CAP(一致性、可用性、分区容忍度)中任选两项，基于节点的分布式系统中，
		  很难全部满足，对事务的支持性不是很好。但也可以使用事务。
	性能：关系型数据库为了维护数据一致性付出了巨大代价，读写性能比较差，而nosql是键值对存储的，并且存储在内存中，读写性能好。
	授权：大多数关系型数据库都是付费的，而nosql通常都是开源的。












		