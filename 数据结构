向量vector
双向链表list
栈
队列
树：
	树节点：{数据元素、第一儿子指针、下一兄弟指针}
二叉树：
	每个节点只有最多两个子树，所以二叉树节点：{数据元素，左节点指针，右节点指针}
	二叉树的第N层上最多有2的n-1次方个节点
	深度为k的二叉树至多有2的k次方-1个节点
	设叶子节点数为n0，度为2的节点数为n2那么，n0=n2+1
二叉查找树：
	定义：左节点<父节点<右节点
满二叉树：
	深度为k，节点数为2的k次方-1个
	//树最后一层没有任何子节点，其余每一层的所有节点都有2个子节点
完全二叉树：
	具有n个节点的完全二叉树的深度为log2n+1
	如果二叉树的深度为k，则除第k层外其余所有层节点的度都为2，
	且叶子节点从左到右依次存在。
	也即是，将满二叉树的最后一层从左到右依次删除若干节点就得到完全二叉树。
	满二叉树是一棵特殊的完全二叉树，但完全二叉树不一定是满二叉树。
AVL	: 平衡二叉查找树
	其每个节点的左子树和右子树的高度最多相差1
	深度：最大层次数
树遍历：
		先序遍历：根节点--左子树--右子树
		中序遍历：左子树--根节点--右子树
		后序遍历：左子树--右子树--根节点
散列表：
	固定表大小
	hash函数
	散列到同一个值(即通过hash函数的结果一样)的冲突解决：
		分离链接法：将散列到同一个值的元素放到一个链表中
		开放定址法：不使用链表，也叫探测散列表：
				线性探测：如果发生冲突，就循环散列表往下找合适的位置
				平方探测：如果发生冲突，就按平方步长循环往下找合适的位置
				双散列：如果发生冲突，就再次散列
		
图：
	广度优先搜索：
		解决最短路径问题
-----------递归与分治----------------------
递归要素：
	递归模式
	边界条件
效率：
	递归效率低，尾递归可以改为循环以提高效率
分治：
	将大问题分为小问题
————————————————————————————————查找算法————————————————————————————————
————————————————————————————————排序算法————————————————————————————————
冒泡排序----稳定------------------------https://www.cnblogs.com/hokky/p/8529042.html
	双重循环，可设置flag，若某一趟已经有序就返回完成
选择排序----不稳定
	在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；
	第二次遍历n-2个数，找到最小的数值与第二个元素交换；
	......
	第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。
插入排序----稳定
	直接插入排序
	折半插入排序
	希尔排序
	将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，
	则交换，直到全部元素都比较过。
希尔排序----不稳定
	将待排序数组按照步长进行分组，然后将每组的元素利用直接插入排序的方法进行排序；
	每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。
快速排序----不稳定
	挖坑填数+分治法
    从序列当中选择一个基准数(pivot)
    在这里我们选择序列当中第一个数最为基准数
    将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧
    重复步骤1.2，直到所有子集当中只有一个元素为止。
归并排序----稳定
	将已有的子序列合并，达到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
基数排序----稳定
	通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。
	分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中
	收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]
	对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束
堆排序
桶排序
计数
————————————————————————————————常用的数据结构——————————————————————————————
平衡二叉树
红黑树
B-树
KMP算法
栈/队列
布隆过滤器








