逻辑结构四种：
	集合
	线性
	树形
	图状或网状
存储结构四种：
	顺序存储
	链式存储
	索引存储
	散列存储
时间复杂度：
	在N取得很大时，从小到大排序
	常数阶 < 对数阶  < 线性阶 < 线性对数阶 < 平方阶 < 立方阶 < K次方阶 < 指数阶
	O(1)     O(LogN)   O(N)     O(NlogN)      O(N²)   O(N³)               O(2的n次方)
线性结构：
	向量vector
	双向链表list
	栈
	队列
	串：数据元素只能是字符
树：
	树节点：{数据元素、第一儿子指针、下一兄弟指针}
二叉树：
	每个节点只有最多两个子树，所以二叉树节点：{数据元素，左节点指针，右节点指针}
	二叉树的第N层上最多有2的n-1次方个节点
	深度为k的二叉树至多有2的k次方-1个节点
	设叶子节点数为n0，度为2的节点数为n2那么，n0=n2+1
满二叉树：
	深度为k，节点数为2的k次方-1个
	//树最后一层没有任何子节点，其余每一层的所有节点都有2个子节点
完全二叉树：
	具有n个节点的完全二叉树的深度为log2n+1
	如果二叉树的深度为k，则除第k层外其余所有层节点的度都为2，
	且叶子节点从左到右依次存在。
	也即是，将满二叉树的最后一层从左到右依次删除若干节点就得到完全二叉树。
	满二叉树是一棵特殊的完全二叉树，但完全二叉树不一定是满二叉树。
---------------二叉查找树、AVL、红黑树区别------------------------------------------
二叉查找树：
	定义：左节点<父节点<右节点
AVL	: 平衡二叉查找树
	是一个二叉查找树，并且每个节点的左子树和右子树的高度最多相差1
	平衡度比红黑树高，适用于查询多，增删少的情况，为了保持平衡可能需要多次旋转
红黑树：
	1. 每个节点非红即黑
	2. 根节点是黑的;
	3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;
	4. 如图所示，如果一个节点是红的，那么它的两儿子都是黑的;
	5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;
	6. 每条路径都包含相同的黑节点;
	适用于查询少，增删多的情况，为了保持平衡比AVL旋转次数少
树遍历：
		先序遍历：根节点--左子树--右子树
		中序遍历：左子树--根节点--右子树
		后序遍历：左子树--右子树--根节点
散列表：
	固定表大小
	hash函数
	散列到同一个值(即通过hash函数的结果一样)的冲突解决：
		分离链接法：将散列到同一个值的元素放到一个链表中
		开放定址法：不使用链表，也叫探测散列表：
				线性探测：如果发生冲突，就循环散列表往下找合适的位置
				平方探测：如果发生冲突，就按平方步长循环往下找合适的位置
				双散列：如果发生冲突，就再次散列
-----------------------------------------MySQL索引数据结构---------------------------------------------------------------------------
B树：
	在红黑树的基础上，每个节点可以存放多个数据，每个对应的索引的值上放对应的数据
B+树：
	B树的变种，非叶子节点是会重复的，只在叶子节点上存放数据，非叶子节点只存放索引数据
	这样一个节点可以存放很多个索引数据，一次IO就可以拿到很多数据。
————————————————————————————————查找算法————————————————————————————————
————————————————————————————————十大排序算法——————————————————————————————
冒泡排序----稳定
	双重循环，可设置flag，若某一趟已经有序就返回完成,平均复杂度O(N^2)
选择排序----不稳定
	在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；
	第二次遍历n-2个数，找到最小的数值与第二个元素交换；
	......
	第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。平均复杂度O(N^2)
插入排序----稳定
	直接插入排序
		将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过,平均复杂度O(N^2)
	折半插入排序
		既然前边有序，就折半查找当前待排序元素对应的位置，平均复杂度O(NLogN)
希尔排序----不稳定
	将待排序数组按照步长进行分组，然后将每组的元素(两个一组，例如a[0]和a[gap]、a[1]和a[gap+1]...)利用直接插入排序的方法进行排序；
	每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。缩小增量排序，平均复杂度大概为O(1.5N)
快速排序----不稳定
	挖坑填数+分治法
    从序列当中选择一个基准数(pivot)
    在这里我们选择序列当中第一个数最为基准数
    将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧
    重复步骤1.2，直到所有子集当中只有一个元素为止。平均复杂度O(NLogN)
归并排序----稳定// 用于有序序列合并
	归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。
	首先考虑下如何将2个有序数列合并。这个非常简单，只要从比较2个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。
	然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。平均复杂度O(NLogN)
堆排序----不稳定
	最小堆或最大堆，平均复杂度O(NLogN)
桶排序
	1、将元素按照区间分到不同的桶中
	2、对每个桶内的元素进行排序。可以选择任意一种排序算法。
	3、将各个桶中的元素合并成一个大的有序序列。
基数排序----稳定
	通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。
	分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中
	收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]
		  对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束
	基数排序也是一种桶排序。桶排序是按值区间划分桶，基数排序是按数位来划分；基数排序可以看做是多轮桶排序，每个数位上都进行一轮桶排序。
计数排序
	首先创建数组A[MaxValue]；然后将每个数放到相应的位置上（例如17放在下标17的数组位置）；最后遍历数组，即为排序后的结果。
	计数排序本质上是一种特殊的桶排序，当桶的个数取最大( maxV-minV+1 )的时候，就变成了计数排序。
————————————————————————————————常用的数据结构——————————————————————————————
平衡二叉树
红黑树
B-树
KMP算法
栈/队列
布隆过滤器








