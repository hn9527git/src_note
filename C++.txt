volatile：
	当可以用编译器的控制或检测之外的方式改变对象值的时候，当声明为volatile，给编译器
		的指示是这样的对象不应该执行优化（比如放在寄存器中）。而应给其存储空间，每次去实际地址取值，而不是寄存器。
		禁止编译器可能的优化行为(将经常用的变量自动放在寄存器中)
explicit:
	抑制由构造函数定义的隐式转换；只能用在类内部的构造函数声明上。外部定义时不再重复它。
	除非有明显理由要定义隐式转换，否则单形参构造函数应该定义为explicit，若有转换需要，还可以
	显式使用构造函数来转换。
	声明后，该类构造函数只能用于直接初始化A item(string)
	而不能使用拷贝初始化A item2=string;
extern "C"
	必须出现在函数的第一次声明上，extern "C" 函数
	编译器按照处理C语言的方式处理代码
		extern “C” double calc(){};
		C语言不支持重载，若链接多个C++重载函数出错	
extern int a;//在某个头文件中声明
	· 声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块(文件)中使用，
	  记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用A模块(编译单元)
	  中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，
	  但它不会报错，它会在连接时从模块A生成的目标代码中(.o文件)找到此变量或函数
声明与定义：//分离式编译
	extern int a;//可以声明多次，但只能定义一次，使用时需要包含定义该变量的文件，
	只告诉编译器类型和名字
	int a;//定义，分配了存储空间，可以给一个初始值
#pragma once
    这个的做用就是防止头文件多次包含//
    	由编译器提供保证：同一个文件不会被编译多次。注意这里所说的“同一个文件”
    	是指物理上的一个文件，而不是指内容相同的两个文件。
   	另一种方法使用//C++常用这种方式
   	#ifndef xx.h 
   	#define xx.h  
   		内容
   	#endif 
assert预处理宏：
	assert(表达式);//为假，输出信息并终止程序，为真，则什么也不做
	//关闭：需要在包含头文件的上边定义NDEBUG，或在命令行中指定宏NDEBUG，或在make文件中定义
		#define NDEBUG
		#include <assert.h>
正负数内存表示：//都存储的补码
	正数：正数补码就是本身
	负数：负数的补码就是相应正数按位取反后加一
字面值常量：
	一望而知，例如42
转义序列：
	/(后接三位八进制数有效)
	/x(后面所有数字有效)
宽字符：wchar_t
	L"中国"
初始化和赋值不同：
	初始化是创建时给予一个值
	赋值是擦除当前变量，用新值替代
列表初始化：
	C++11新标准，如果使用初始化列表且初始值存在丢失信息的风险时
	(例如将double赋值给int//int i{d})，编译器报错
void *指针：
	没办法访问内存空间，只能与其他指针比较，作为函数输入输出，或者赋值给void*指针
const:
	仅在文件内有效，不同文件的同名const变量属于分别定义了独立的变量
	要想共享的解决办法：不管声明还是定义都加上extern即可。
	预处理编译和汇编不需要其值，链接时需要其生成的.o目标文件
顶层const:
	表示指针本身是一个常量
	不能作为普通重载函数的区别
底层const://指针本身可以变，但不能通过该指针修改所指或所引的值
	表示所指的对象是一个常量
	//用于声明引用的都是底层const
	//拷出拷入对象必须具有相同的底层const资格，或者数据类型可以转换
	//对常量取地址是一个底层const
	//对变量取地址是一个顶层const
类型别名：
	typedef char * p;
	const p cp=0;//cp是一个指向char的常量指针
	//替换理解是错误的，const和char *都是修饰cp的
别名声明：
	using Si=Sales_item
auto:
	让编译器通过初始值来推算变量的类型//必须有初始值
	一般忽略顶层const(可以加上)，保留底层const
	//不能为非常量引用绑定字面值 auto &h=42;错误
decltype:
	从表达式的类型推断出要定义的变量的类型，但不用表达式的值初始化变量
	//只用类型不用值
	//顶层底层const都不忽略
	引用：int &r=42，*p=&42;
		decltype(r) a;  //a是一个int &
		decltype(r+0) b;//b是一个int
	解引用时，decltype(*p)返回引用类型
	括号：编译器当作表达式 int i=0;
		decltype((i)) c=0;//c是int &,绝对是引用
		decltype(i) d;	  //d是int
字面值和string相加：//二者不同
	必须保证每个加号的两侧对象至少有一个是string
建议：使用C++版本的C标准库头文件
	C：  name       //不一定属于std
	C++: cname		//定义的名字从属于std
引用：
	不是对象，不存在包含引用的vector或数组
迭代器的cbegin()和cend()方法：
	不管对象本身是否是常量，返回const_iterator类型
数组指针：
	char a[6];
	auto a1(a); 发生转换，相当于 a1(&a[0]) //a1是char *
	decltype(a) a2;不发生转换，a2是一个包含六个char的数组
	也可以使用begin()和end()获取首指针和尾指针(不是成员函数)
C风格字符串：不建议使用
	以空字符结束，一般利用指针来操作这些字符串，如果末尾不加空字符，其很多方法都不能正确使用，
	引发溢出错误
string对象与C风格字符串衔接混用：
	· 允许以空字符结束的字符数组来初始化string对象或为其赋值
	· string对象可以和其相加，或将其作为复合赋值运算的右侧运算对象
	· const char * str=s.c_str();//s为string对象，转化为c风格字符串
左值和右值：
	当一个对象被用作右值时，用的是对象的内容
	当被用作左值时，用的时对象的身份(内存地址)
转换：
	static_cast<to>(from)
		不包含底层const可以使用，告诉编译器不在乎精度损失
	const_cast<to>(from)
		只能改变运算对象的底层const
	reinterpret_cast<to>(from)
		为运算对象的位模式提供较低层次上的重新解释
		//例如将int *转换为char*
	dynamic_cast<to>(from)
		运行时识别
try:
	try块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问
标准异常：
	exception:只报告异常的发生，不提供任何额外信息
	domain:逻辑错误，参数对应的结果值不存在
	invalid_argument:逻辑错误，无效参数
	仅能默认初始化：bad_cast、exception、bad_alloc
标准异常类层次：
						exception
	---------------------------------------------------------
	|	            |                  |                     |
bad_cast        runtime_error       logic_error          bad_alloc
			--------------------  ---------------------		
			1.overflow_error       1.domain_error
			2.underflow_error      2.invalid_argument
			3.range_error		   3.out_of_range
								   4.length_error
what()函数：
	异常类定义，返回一个c风格字符串，提供异常信息(指定或默认)
析构函数不应该抛出异常：
	若有异常，应在析构函数内部使用try catch在内部解决
	若抛出了异常，而且析构函数本身没有捕获到该异常，则程序被终止
catch(...):
	捕获所有异常，放在最后
构造函数中也可以使用try  catch：
	Blob() try : data(new string("wc")) {} catch(bad_alloc &e){处理异常;}
noexcept:
	旧标准：throw();加在函数后表明不会抛出异常
	C++11标准：加在函数声明后(const以及引用之后，或final、override、=0之前)
			   表明该函数不会抛出异常
    如果不守规矩，还是抛出异常，那么就会调用terminate退出
    当运算符使用：
    	noexcept(e);//当e调用的所有函数都做了不抛出说明并且本身不含有throw语句时为true
    				否则为false
    指针：做了不抛出异常声明，则该指针只能指向不抛出异常的函数
    虚函数：如果一个虚函数承诺不会抛出异常，那么后续派生出来的虚函数也必须做出同样的承诺
可变形参：
	initializer_list<int> lint：
		void f(initializer_list<string> ls)
		{
			for(auto elem:ls)
			{
				cout<<elem<<endl;
			}
		}
	调用：f({"wo","ni","ma"})
		类似vector，但值永远是常量值
	省略符形参：
		void f(...)
返回列表：
	vector<string> f()
	{
		return {"wo","ni","ma"};
	}
类的常量对象：
	以及常量对象的引用或指针都只能调用常量成员函数
类的编译：
	首先编译成员的声明，然后成员函数体，所以成员函数可以随意使用类的其他成员
	而无需在意这些成员的出现次序
类内初始值：
	必须以符号=或者花括号表示
	默认构造函数用它来初始化成员，若没有类内初始值，执行默认初始化该成员
	建议使用，防止const或引用类型未初始化可能引发的错误
	要么使用花括号，要么使用等号，不能使用圆括号//语义分析有歧义，可能被当作函数
可变数据成员：
	mutable a=10;
	永远不会是const，即使它是const对象的成员也可以修改
const成员函数：
	const修饰this
	从const成员函数返回*this，那么它的返回类型是const引用!!!
缓冲刷新：
	· 程序正常结束
	· 缓冲区满了
	· 使用操纵符endl：换行并刷新
			   flush：刷新缓冲但不输出任何字符
			    ends：向缓冲区插入一个空字符后，刷新缓冲
	· 使用unitbuf设置流得内部状态，来清空缓冲区
			cout<<unitbuf;//所有输出操作后立即刷新
			cout<<nounitbuf;//回到正常缓冲
	· 一个输出流关联到另一个流。当读写关联的流时，被关联的流的缓冲区会被刷新
		默认cin和cerr都被关联到cout，所以读写cin和cerr都会刷新cout的缓冲区
		cin.tie(&cout);//标准库将cin和cout关联
文件模式：
	每个流都有一个关联的文件模式，用来指出如何使用文件
	in 		读方式打开
	out 	写方式打开//现有内容被丢弃
	app 	每次操作前定位到文件末尾
	ate 	打开文件后立即定位到文件末尾
	trunc 	截断文件
	binary 	以二进制方式IO
	例：ofstream out;
		out.open("a.txt",ofstream::app)
内存IO流：
	输入输出string，就像string是一个IO流一样
	istringstream流：
	//         地址，大小，分隔符(不写默认为换行)
	cin.getline(buf,size,'\n');
	istringstream record(line);
	record>>str;
标准array: c++11
	固定大小，不能删除和插入，可以通过下标修改成员值
	array<int 42> a;//保存42个int的数组，必须有大小
	内置数组类型不能进行拷贝或对象赋值操作
	但标准array可以
	array<int,42> b=a;//类型匹配就合法
	不允许花括号包围的值列表进行赋值//测试是可以的！
swap:
	元素不会被移动，除string外，指向容器的迭代器、引用和指针不会失效
	//因为string可能会被存储在栈上
	标准array使用swap时会真正交换元素
insert:
	将元素插入到迭代器所指定位置之前
	vector不支持push_front，但可以使用insert
emplace_front\emplace\emplace_back
	这些操作构造而不是拷贝元素，调用时将参数传递给元素类型的构造函数
	struct Foo {
    Foo(int n, double x);
	};
	//避免产生不必要的临时变量，将参数直接送给元素类型(在这里是类类型Foo)的构造函数
	std::vector<Foo> v;
	v.emplace(someIterator, 42, 3.1416);        // 没有临时变量产生
	v.insert(someIterator, Foo(42, 3.1416));    // 需要产生一个临时变量
	v.insert(someIterator, {42, 3.1416});       // 需要产生一个临时变量
at：
	容器下标操作可能越界造成运行时错误，使用at函数可以确保下标合法
stod:
	将string转换为浮点值(string中第一个非空白字符必须是数值中可能出现的字符[+-.0-9])
适配器：
	一种机制，使某种事物的行为看起来像另外一种事物一样
	一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型
	stack、queue、proiority_queue
流迭代器：
	istream_iterator:读取输入流
		定义：istream_iterator<> it(cin),eof;
	ostream_iterator:写输出流
		定义：ostream_iterator<> it(cout,"分隔符");
双向链表和单链表：#include<list>
	定义了独有的
		sort：使用<或给定比较操作排序
		merge：有序序列合并
		remove：删除与给定值相同的元素
		reverse：反转元素
		unique：删除相同值得连续拷贝，可给定二元谓词
		splice:复杂暂时不写
	应优先使用成员函数算法而不是通用算法
关联容器：
	有序：
		map:键值对
		set:只保存关键字
		multimap:可重复map
		multiset:可重复set
	无序：
		unordered_map:哈希函数组织的map
		unordered_set:哈希函数组织的set
		unordered_multimap：同上且可重复
		unordered_multiset：同上且可重复
智能指针：
	shared_ptr:允许多个指针指向同一个对象
	unique_ptr:独占所指向的对象
shared_ptr：
	shared_ptr<类型> p;//可以指向某种指定类型	
	p.get();			//返回p中保存得指针(内置指针)，不能delete该指针
						不要使用get初始化另一个智能指针或给另一个智能指针赋值
	p.swap(q);			//交换指针
	make_shared<T>(args);//返回一个shared_ptr,指向args初始化的对象
	shared_ptr<T>p(q);	//拷贝，递增q的计数器
	p=q;				//递减p的计数，递增q的计数
	p.unique();			//若p.use_count()为1，返回true
	p.use_count();		//返回与p共享对象的智能指针的数量
	引用计数:每当有新的指针指向自身指向的对象时递增，被赋予新值或离开作用域时递减
			为零时自动释放所指向的对象
	接受指针参数的智能指针构造函数是explicit的：
		shared_ptr<int> p1=new int(0)；//错误，不能将内置指针隐式转换为智能指针
		shared_ptr<int> p2(new int(0));//直接初始化可以
		shared_ptr<int> p3(q);//p管理内置指针q所指向的对象
	智能指针也可以绑定到其他类型的资源的指针上：//非动态内存普通指针
		但是需要提供自己的delete操作来释放资源
		shared_ptr<T> p(q,d);//q必须能转换为T*,d代替delete
	p.reset();//唯一指向对象的指针则释放
	p.reset(q);//令p指向q
	p.reset(q,d);//调用d来释放q
unique_ptr：
	某个时刻只能有一个unique_ptr指向一个给定对象，当unique_ptr销毁时，指向的对象也销毁
	定义时需要将其绑定到一个new返回的指针上//没有类似make_shared的函数返回unique_ptr
		unique_ptr<T> p1(new int(42));
		unique_ptr<T> p2;//可以指向一个double的unique_ptr
		不支持拷贝和赋值操作
		例外：我们可以拷贝或赋值一个将要被销毁的uniqued_ptr
			例如：从函数返回 return unique_ptr<int>(new int (p));//函数参数 int p
				  或返回一个局部对象的拷贝 return ret;//unique_ptr<int> ret(new int (p))
	u.release();//放弃对指针的控制权，返回指针，将u置空
	u.reset(q);//释放u所指的对象，若提供q则令u指向该对象
	提供删除器：
		unique_ptr<obj,delT> p (new obj,fcn);
weak_ptr:
	一种不控制所指向对象生存期的智能指针，指向一个shared_ptr管理的对象
	在确定是否应该释放对象时，shared_ptr不把weak_ptr统计在内
	//不知道有什么用先不写
加括号区别：
	int * p=int;  //p指向未初始化的int
	int * q=int();//p指向值初始化为0的int
	只对内置类型有差异
	对定义了构造函数的类来说，不管采用了什么形式，对象都会通过默认构造函数来初始化
使用默认构造函数：
	A item();//错误，声明了一个函数而非对象，hh
	A item;//使用了默认构造函数的一个对象
临时对象：
	生存期，该表达式的末尾;，例如const string *p=str1.substr(a).data();
			再去使用p指向的空间时，其上临时对象已经被销毁
			//应声明一个变量，用临时变量赋值
空悬指针：
	指向一块曾经保存数据对象但是现在已经是无效的内存的指针
动态数组：//并非数组类型
	使用容器的类可以使用默认版本的拷贝、赋值、和析构操作
	分配动态数组的类则必须定义自己版本的操作，在拷贝、赋值、和析构中管理所关联的内存
	new分配对象数组：
			int * p=new int[size];//p指向第一个int
		或：typedef int a[42];
			int *q=new a;
	    返回一个数组元素类型的指针，指向第一个元素
	释放：
		delete p;//p必须指向一个动态分配的对象或为空
		delete [] pa;//pa必须指向一个动态分配的数组或为空，数组中元素逆序销毁
auto_ptr类：
	只能用于管理从new返回的一个对象，他不能管理动态分配的数组。
allocator:
	可以将内存分配和对象构造分离开来。它分配的内存是原始的，未构造的。
	是一个模板，必须指明它可以分配的对象的类型
		allocator<string> alloc;//可以分配string的allocator对象
		auto const p=alloc.allocator(n);//分配n个未初始化的string对象
		alloc.deallocate(p,n);//释放指针p中地址开始的内存，n必须是p创建时要求的大小
			调用本方法前，用户必须对每个在这块内存中的创建的对象调用destory
		alloc.construct(p,args);p指向原始内存，arg被传递给类型T的构造函数，
			用来在p指向的内存中构造一个对象
		alloc.destory();//对p指向的对象执行析构函数
	它分配的内存是为构造的，我们需要在此内存中构造对象。
		auto q=p;
		alloc.construct(q++,10,'c');//
		未构造对象就使用原始内存是错误的
	元素被销毁后，就可以重新使用这部分内存来保存其他string，也可归还给系统
		alloc.deallocate(p,n);
	拷贝和填充未初始化内存的算法：
		uninitialized_copy(b,e,p);//从迭代器b和e指定的范围内拷贝元素到迭代器p
			指定的未构造的原始内存中，p指向的内存必须够大，足够容纳这些元素
		uninitialized_copy_n(b,n,p);//从迭代器b开始的n个元素拷贝到p指定的
			未构造的原始开始的内存中
		uninitialized_fill(pb,pe,t);//在迭代器pb和pe指定的未构造的原始内存范围
			内创建对象，对象的值全部是t的拷贝
		uninitialized_fill_n(pb,n,t);//在迭代器pb开始的未构造的原始内存中开始
			创建n个对象，对象的值全部是t的拷贝
重写（覆盖）override
	override是重写（覆盖）了一个方法，以实现不同的功能。一般用于子类在继承父类时，重写（覆盖）
		父类中的方法。函数特征相同，但是具体实现不同。
	重写需要注意：
		被重写的函数不能是static的，必须是virtual的
		重写函数必须有相同的类型，名称和参数列表,返回类型也必须与基类函数匹配，但有一个例外：
				当类的虚函数返回类本身的指针或引用时，派生类虚函数可以返回自己的引用或指针
		重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public、
		protect也是可以的
重载overload
	overload是重载，一般是在一个类实现若干重载的方法，
	这些方法的名称相同而参数形式不同。但是不能靠返回类型来判断。
	顶层const不构成重载
	重载需要注意：
    		位于同一个作用域中
    		函数的名字必须相同
    		形参列表不同
		基于成员函数是否为const，也可以重载
		当参数是引用或指针是，是否const和是否volatile和是否explicit也构成重载
    	若一个重载版本的函数面前有virtual修饰，则表示他是虚函数，但他也是属于重载的一个版本
    		不同的构造函数(无参构造、有参构造、拷贝构造）是重载的应用
    匹配：//按顺序寻找
    	1.精确匹配
    	2.const转换匹配
    	3.类型提升匹配
    	4.算术类型转换或指针转换匹配
    	5.类类型转换匹配
重定义(隐藏)redefining
	派生类对基类的成员函数重新定义，即派生类定义了某个函数，该函数的名字与基类中函数名字一样。
	重定义也叫做隐藏，子类重定义父类中有相同名称的函数（参数可以不同）。如果一个类，
	存在和父类相同的函数，那么这个类将会覆盖其父类的方法，除非你在调用的时候，强制转换为父类类型，
		否则试图对子类和父类做类似重载的调用时不能成功的。
	重定义需要注意：
    		不在同一个作用域（分别位于基类、派生类）
    	函数的名字必须相同
    	对函数的返回值、形参列表无要求
    	若派生类定义该函数与基类的成员函数完全一样（返回值、形参列表均相同），且基类的该函数
    	为virtual，则属于派生类重写基类的虚函数
多态polymorphism
　　多态的概念比较复杂，一种不严谨的说法是：继承是子类使用父类的方法，而多态是父类使用子类的方法。
　　一般我们使用多态是为了避免在父类里大量重载引起代码臃肿且难于维护。
　　多态分为两类：静态多态性和动态多态性，函数重载和运算符重载实现的多态性属于静态多态性，
	在程序编译时系统就能决定调用哪个函数，因此静态多态性又称为编译时的多态性。
	静态多态性是通过函数的重载实现的。
	动态多态性是在程序运行过程中才动态地确定操作所针对的对象。它又称运行时的多态性。
	动态多态性是通过虚函数实现的。
动态绑定：
	只有通过基类的引用或指针调用虚函数(传给基类的引用或指针参数)，才会发生动态绑定：即运行时绑定
常量成员函数：
	double avg_price() const;
	const 成员不能改变其所操作的对象的数据成员。const 必须同时出现在声明和定义中，
		若只出现在其中一处，就会出现一个编译时错误。
成员函数重载
	只能重载本类的其他成员函数。类的成员函数与普通的非成员函数以及在其他类中声明的函数不相关，
	也不能重载它们。
	using 声明把基类中每个被命名的成员都引入到派生类的域中 现在 
	基类成员就可以进入到 与派生类中的成员函数名字相关 的重载实例集中 
	针对一个成员函数的using 声明不能指定参数表 只能指定成员函数名 
	这意味着 如果该函数在基类中被重载则所有的重载实例都被加入
	到派生类类型的域中 我们不能只增加基类的重载成员函数集中的一个实例
	using 父类::成员函数名;
不完整类型：
	在声明之后，定义之前，是一个不完整类型，不能定义该类型的的对象，只能定义指向该类型
	的指针以及引用，
		或者用于声明使用该类型作为形参类型或返回类型的函数；例如定义链表类时或单例类；
this指针：
	在普通非CONST成员函数中，是一个指向类类型的const指针，在const成员函数中是一个指向
		const类类型对象的const指针；
大小端：
	大端模式，是指数据的高字节保存在内存的低地址中，
		而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作
		字符串顺序处理：地址由小向大增加，而数据从高位往低位放；
	小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，
		这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。
类成员作用域：
	不仅要考虑在本类<定义>之前的全局作用域中的[声明]，而且要考虑在成员函数<定义>之前出现的
	全局作用域[声明]。
类型名：
	如果类成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后
	重新定义该名字，所以类型名的定义通常放在类的开始处。
初始化：
	在局部作用域中内置类型成员不被初始化，在全局作用域中他们被初始化为0；
初始化列表：
	先于花括号内的初始化操作执行
	<只能初始化，不能复制>
	以下不管是哪种类型，都在构造函数初始化列表中或提供类内初始值进行初始化;
	1.初始化引用
	2.初始化const成员
	3.当调用一个基类的构造函数，而它拥有一组参数
	4.当调用一个成员类对象的构造函数，而它拥有一组参数
初始化次序：
	就是定义成员的次序，不是初始化列表中的次序。
类成员的初始化和赋值：
	如果没有在构造函数的初始化列表中显示地初始化成员，则该成员将在构造函数体之前
	执行默认初始化
声明对象和new对象的区别：
	new出来的对象是直接放在堆上，而声明一个对象是放在栈中。
	声明的作用域限制在定义类对象的方法中，当方法结束时，类对象也被系统释放了，
	（安全不会造成内存系统泄漏）。
	new 创建的是指向类对象的指针，作用域变成了全局，当程序结束时，必须用delete删除，
	系统不会自动释放，（不注意可能造成内存泄漏）
显式初始化：==不建议
	对于没有定义构造函数！！！并且其全体数据均为public的类
	(就像一个普通的struct)，可以采用与初始化数组元素相同的方式初始化其成员。
	A a = { 6,6,6 };
委托构造函数：
	使用它所属类的其他构造函数执行它自己的初始化过程
	A() : A("",0,0);//默认构造函数使用了有三个参数的构造函数
静态成员：
	外部定义时，无需重复指定static保留字，该保留字只出现在声明处；
	static函数没有this指针；
		因为static成员函数是类的组成部分但不是任何对象的组成部分，没有this指针(const修饰this)，所以也不能被声明为const；，
		也不能被声明为虚函数；
	static数据成员必须在类定义体的外部定义正好一次；他不是通过类构造函数进行初始化，
		而应该在定义时进行初始化；
		-- 类的数据成员不能在类定义体中初始化，例外：只要初始化式是一个常量表达式，
		-- const static数据成员就可以在类的定义体中进行初始化，const static数据成员
		-- 在类的定义体中初始化时，该数据成员仍必须在类的定义体之外进行定义，
			若在类内部提供初始化式时，成员的定义不必再指定初始值；
		-- const static数据成员的类型可以是该成员所属的类类型(不完全类型)。
		-- const static数据成员可用作默认实参
控制对象拷贝、移动、赋值、销毁的五种特殊成员函数：
	1.拷贝构造函数
	2.拷贝赋值运算符
	3.移动构造函数
	4.移动赋值运算符
	5.析构函数
1.复制构造函数：
	具有单个形参，该形参(常用const修饰)必须是对该类类型的引用，或任何额外参数都有默认值
	·显式使用：当定义一个新对象并用一个同类型的对象对它进行初始化时。
	·隐式使用：当将该类型的对象传递给函数或函数返回该对象类型的对象时。
	直接初始化：将初始化式放在圆括号中。-》直接调用实参匹配的构造函数。
	复制初始化：使用=符号。-》创建临时对象——》复制到正在创建的对象
	-- 形参与返回值：为类类型时，使用复制构造函数进行复制
	-- 初始化容器元素：-》默认构造创建临时值-》复制构造复制到每一个元素
	-- 数组元素：若没有提供类类型的元素初始化，则默认构造初始化每个元素。
		若使用花括号初始化列表，则先创建后复制。
	若定义了复制构造函数，也应该定义默认构造函数
1.默认复制构造函数：
	编译器在必要的时候才会合成出来//即使定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数
	若类没有表现出位逐次拷贝语义，应当合成一个默认复制构造函数
	一个类不展现出位逐次拷贝语义的四种情况：
	1.类中含有类成员对象，并且该成员类对象含有复制构造函数
	2.类继承自一个基类而且基类存在复制构造函数（无论是明确声明或合成所得）
		//这两中情况，合成的复制构造函数会调用安插类成员对象或基类的复制构造函数
	3.当类声明了一个或多个虚函数时
		//此种情况下，复制构造函数需要控制正确地安插虚函数表指针，所以要合成
	4.类派生于一个继承串链，其中有一个或多个虚基类时
		//问题发生在用派生类构造基类时，派生类被切割，编译器要控制正确地安插虚函数表指针
2.拷贝赋值运算符：
	重载operate=函数，可以对赋值进行定义。
	-- 为类成员时，第一个操作数隐式绑定到this指针，右操作数一般为const引用传递。
	-- 返回值一般为类引用。
	复制构造函数和赋值操作符应一起出现。
	注意：
		· 如果将一个对象赋值给自身，赋值运算符必须能正常工作//不要上来就释放左侧对象
		· 大多数赋值运算符组合了析构函数和拷贝构造函数的工作
5.析构函数：
	析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的
	逆序撤销每个非static成员。
	即使我们编写了自己的析构函数，合成析构函数仍然运行。
	隐式销毁一个内置指针类型的成员不会delete他所指向的对象
	当指向一个对象的引用或指针离开作用域时，析构函数不会执行
	动态分配的对象只有在指向该对象的指针被删除时才撤销。
	当对象的引用或指针超出作用域时，不会运行析构函数。只有删除指向动态分配对象的
	-- 指针或实际对象超出作用域时，才会运行析构函数。
	--容器中的对象逆序析构。
	三法则:需要析构函数的类也需要复制构造函数和赋值操作符。
		   需要拷贝操作的类也需要赋值操作
		   需要赋值操作的类也需要拷贝操作
=default:
	将拷贝控制成员定义为=default来显式要求编译器生成合成的版本//隐式声明内联
	如果不希望合成的是内联，则只对成员的类外定义使用=default即可
阻止拷贝：
	定义删除的函数：//新标准
		NoCopy(const NoCopy&)=delete;//阻止拷贝
		NoCopy &operator=(const NoCopy&)=delete;//阻止赋值
	新标准之前：
		将拷贝构造函数和拷贝赋值运算符为private，类的友元和成员仍可复制。
		若声明但不定义则绝不能复制。
行为像值的类：
	需要：定义拷贝构造函数完成string的拷贝
		  定义析构函数释放string
		  定义拷贝赋值运算符释放当前string，并从右侧对象拷贝string
行为像指针的类：
	需要：
		定义拷贝构造函数来拷贝指针本身
		定义拷贝赋值运算符来拷贝指针本身
		//析构函数不能单方面地释放指针指向的对象，只有在最后一个指向指针对象的对象
			销毁时才可以释放指针对象最好使用shared_ptr或想直接管理就使用引用计数
		//定义一个保存在动态内存中的计数器，每次拷贝都将其值递增，析构就递减
		不能使用静态成员变量保存计数器，因为new对象时其值是之前拷贝的数量而不是1
在赋值运算符中使用swap：
	H& H::operator=(H rhs)
	{
		swap(*this,rhs);
		return *this;
	}
	使用swap将本对象和rhs交换，当赋值运算符结束后，rhs被销毁
	他自动处理了自赋值情况且天然就是异常安全的
指针成员：
	复制指针时只复制指针中的地址，而不会复制指针指向的对象。
	管理指针常用的三种方法：
	1.指针成员采取常规指针性行为。这样的类具有指针的所有缺陷但无需特殊的复制控制。
	2.类可以实现所谓的智能指针行为。所指对象共享，但类能够防止悬垂指针。
	3.类采取值型行为。指针所指对象唯一，由每个类对象独立管理。复制时得到新副本，例如String类。
重载操作符：
	必须具有至少一个类类型或枚举类型的操作数。
	除了函数调用操作符operator()之外，重载操作符时使用默认实参是非法的。
	复合赋值(+=)返回对左操作数的引用，加操作符返回一个对象(为与内置操作符保持一致)。
	赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）等操作符必
	-- 须定义为成员，将这些操作符定义为非成员函数将在编译时标记为错误。
	? 像赋值一样，复合赋值操作符通常应定义为类的成员，与赋值不同的是，
	-- 不一定非得这样做， 如果定义非成员复合赋值操作符， 不会出现编译错误。
	? 改变对象状态或与给定类型紧密联系的其他一些操作符，如自增、自减和
	-- 解引用，通常就定义为类成员。
	? 对称的操作符，如算术操作符、相等操作符、关系操作符和位操作符，最
	-- 好定义为普通非成员函数。
	输出操作符不应该输出换行符，细节应该交由用户控制
	IO操作符必须为非成员函数：
		否则，左操作数只能是该类类型的对象，例：item<<cout;
		通常设置为友元。
		非常量输入输出对象：因为流会改变状态
		引用：因为无法直接复制一个输出流对象。
		输入时可能发生错误，此时应把对象重置为默认状态，确保对象处于正确的状态
	要输出的参数常设置为const引用。
	要输入的参数必须为非const，因为要读到该对象中。
		输入操作符必须处理错误和文件结束的可能性。if(cin) .. else 复位(默认构造)；
	赋值操作符可以重载，必须定义为成员函数，必须返回对*this的引用。	
	下标操作符定义时，必须是成员函数，一般需要两个版本：一个为非const成员并返回引用，
		一个为const成员返回const引用。
	自增/自减运算符：
		前缀式运算符应该返回递增或递减后对象的引用。
		后缀式运算符应该返回递增或递减前的对象，是一个值而不是引用。
		后缀式操作符函数接受一个额外的int型形参。
		应该被定义为成员函数
	成员访问运算符：
		*：string& operator*() const 
			{	
				return (*p)[curr];		
			}	
	   ->：string* opeartor->() const 
	   		{	
	   			return & this->operator*();//实际工作委托给解引用运算符
	   		}
	   	应该被定义为成员函数。
	函数调用操作符：
		bool operator(const string&s){return s.size()>=this->size}
		必须声明为成员函数。可重载。定义此成员函数的对象称为函数对象。
		标准库定义了一些函数对象，常用来替代算法中的默认运算符。
		函数对象的函数适配器：
			绑定器：将一个操作数绑定给定值而将二元函数对象转换为一元函数对象。
				bind1st和bind2nd：例：count_if(v.begin(),v.end(),
										bind2nd(less_equal<int>(),10);
			求反器：将谓词函数对象的真值求反。
				not1和not2：not1将一元函数对象的真值求反，not2将二元函数对象的真值求反。
				例：count_if(v.begin(),v.end(),
								not1(bind2nd(less_equal<int>(),10);
类类型转换：
	转换操作符：
		operator type() [const];//常为const成员
		必须为成员函数，不能指定返回类型，形参表必须为空。必须显式返回一个指定类型的值。
		只能应用一个类类型转换。
面向对象基本概念：数据抽象、继承、动态绑定
	虚函数：基类希望派生类重写的函数应定义为virtual，希望被继承的函数不能被定义为虚函数。
			非static成员函数。
			派生类必须对想要重定义的每个继承成员进行声明。
			声明必须与基类中的定义方式完全匹配，一个例外：返回对基类的引用或指针的虚函数，
				派生类中的虚函数可以返回基类函数所返回类型的派生类的引用或指针。
			加上域操作符可以强制调用虚函数的特定版本。
			派生类虚函数调用基类版本时，必须显式使用作用域操作符，否则，
				函数调用会在运行时确定并且是一个自身调用，导致无穷递归。
	动态绑定：使用继承层次中的任意对象，运行时指定，通过基类的引用或指针调用虚函数时发生。
			使用条件：1.只有虚函数成员才能进行动态绑定。
					  2.必须通过基类类型的引用或指针进行函数调用。	
	protected成员：派生类只能通过派生类对象访问其基类的protected成员，派生类对
			其基类类型对象的protected成员没有特殊访问权限。//理解重点：派生类对象访问
	派生类可以进一步限制基类的访问权限，但不能放松权限，无论什么访问标号，直接派生类
		对基类成员有相同的访问权限。(即使是private继承，直接派生类还是可以访问直接基类的保护成员)
		派生类访问标号控制派生类的用户对从基类继承而来的成员的访问。
	友元关系不能继承。
改变个别成员的可访问性：
	using 基类成员;//派生类只能为它可以访问的名字提供using声明
继承中的类作用域：
	派生类的作用域嵌套在其基类的作用域之内
转换与继承：
	转换要考虑派生列表中的访问标号。
	派生类对象转换为基类类型的引用：
		派生类对象的地址可以对基类类型的指针进行赋值或者初始化。
		可以使用派生类类型的引用或对象初始化基类类型的引用。
	派生类对象对基类对象进行初始化或赋值：
		将派生类传给希望接受基类类型对象的函数时，派生类的基类部分被复制到形参。
派生类构造函数：
	合成的派生类默认构造函数：
		1.调用基类的默认构造函数，初始化基类部分
		2.用常规变量初始化派生类部分，即未初始化。
	派生类构造函数的初始化列表只能初始化派生类的成员，不能直接初始化继
		承成员。相反派生类构造函数通过将基类包含在构造函数初始化列表中来间接初
		始化继承成员。
继承与复制：
	只含有类类型或内置类型数据成员、不含指针的类一般可以使用合成操作，
	具有指针成员的类一般需要定义自己的复制控制来管理这些成员。
	如果派生类定义了自己的复制构造函数，该复制构造函数一般显式使用基类复制构造
		函数初始化对象的基类部分。
	派生类赋值操作符同上：
		且赋值操作符必须防止自身复制：if(this!=&rhs){再操作};
	派生类析构函数;
		不负责撤销基类部分的成员，编译器显式调用派生类对象基类部分的析构函数。
		首先运行派生类析构函数，再运行基类析构函数。
	防止继承：
		C++11：在类名后跟上一个关键字final
虚析构函数：
	处理继承层次中的对象时，指针的静态类型可能与被删除对象的动态
		类型不同，可能会删除实际指向派生类对象的基类类型指针。
		解释:如果删除基类指针，则需要运行基类析构函数并清除基类的成员，如果对象
			实际是派生类类型，则没有定义该行为。所以析构函数必须是虚函数。
			例：class A;class B:public A; A * p=new B();
构造函数和析构函数中的虚函数问题：
	派生类构造过程中和派生类析构过程中，对象是不完整的。编译器将对象的类型视为
		在此期间发生了变化，将派生类对象当作基类类型对象对待。
		如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数
			自身类型定义的版本。
默认构造函数何时自动生成：
	1.类中含有类对象
	2.基类默认构造构造函数
	3.虚函数
	4.虚基类
	编译器需要时才自动合成，并且需要时还可以扩张已经定义的构造函数
	如果类没有定义构造函数，那也不一定会合成默认构造函数
	编译器合成的默认构造函数不会初始化类中的非静态成员，只会初始化基类对象和成员类对象
继承与类作用域：
	如果不能在派生类作用域中确定名字，就在外围基类作用域中查找改名字的定义。
	名字查找在编译时发生。
	基类类型的指针引用或对象只能访问对象的基类部分。或派生类的虚函数（run time）
	如果派生类重定义了重载成员，则通过派生类只能访问派生类中重定义的那些成员。
	如果派生类想通过自身类型使用的重载版本，则派生类必须要么重定义所有重载版本，要么
		一个也不定义。可以使用using声明将函数的所有重载实例加到派生类的作用域。
		然后只需要重定义本类型确实需要的重载版本即可，其他版本使用继承的定义。
纯虚函数：
	在函数形参表后面写上 =0 以指定纯虚函数
	无需定义，若要定义只能在类的外部
	该函数为后代类型提供了可以覆盖的接口，但这个类中绝对不会调用，
		最重要的是用户不能创建含有纯虚函数的类（抽象基类）的对象。
虚函数的默认实参：
	谁调用就用谁的默认实参，但最好将其默认实参值设为相同的
句柄类：定义包装
	句柄类存储和管理基类指针，指针所指对象的类型可以变化，它既可以指向基类类型对象又可以
		指向派生类对象。用户通过句柄类访问继承层次的操作，因为句柄类使用指针执行操作，
		虚成员的行为将在运行时根据句柄实际绑定的类型而变化，因此，句柄类的用户可以获
		得动态行为但无需操心指针的管理。
	像对任何保存指针的类一样，必须确定对复制控制做些什么。句柄类通常表现得像一个智能指针
		或者像一个值。
	句柄类决定句柄接口屏蔽还是不屏蔽继承层次。
模板：
	定义模板函数:template<typename T> [inline] T min(const T&,const T&);
	定义类模板：template<typename T> class 类名{};
	模板定义中，模板参数列表不能为空
	同一模板的声明和定义中，模板形参的名字不必相同。
	每个非类型形参前面必须带上类型名字。<typename T,L>//error
tuple：
	快速而随意的数据结构
	auto item = make_tuple("09-123",3,20.00,"面向对象");
	auto book = get<0>(item);//返回第一个成员
bitset:
	bitset<32> bit(1U);//32位，低位为1，其他位为0
正则表达式：
	库组件：
		regex: 表示有一个正则表达式的类
		regex_match:将一个字符序列与一个正则表达式匹配
		regex_search:寻找第一个与正则表达式匹配的子序列
		regex_replace:使用给定格式替换一个正则表达式
		regex_iteartor:迭代器适配器
		smatch:容器类，保存在string中搜索的结果
		ssub_match:string中匹配的子表达式的结果
随机数：
	随机数引擎：类型，生成随机无符号整数序列
	随机数分布：类型，使用引擎返回服从特定概率分布的随机数
	C++程序不应该使用库函数rand，而应该使用default_random_engine类和恰当的分布类对象
	例如：default_random_engine e;
		  for(int i=0;i<n;i++)
		  	cout<<e()<<endl;//每次调用生成新随机数
		或者使用u作为随机数源来生成指定范围内并服从均匀分布的值
		  uniform_int_distribution<unsigned> u(0,9);
		  default_random_engine e;
		  for(int i=0;i<n;i++)
		  	cout<<u(e)<<endl;//每次调用生成新随机数
流随机访问：
	istream和ostream不支持随机访问，fstream和sstream支持
	tellg();		返回一个输入流的当前位置
	tellp();		返回一个输出流的当前位置
	seekg();		在输入流中将标记重定位到给定的绝对地址
	seekp();		在输出流中将标记重定位到给定的绝对地址
	seekp(off,from);在一个输出流中将标记定位到from之前或之后off个字符
	seekg(off,from);在一个输入流中将标记定位到from之前或之后off个字符
		from:	beg//偏移量相对于流开始位置
				cur//偏移量相对于流当前位置
				end//偏移量相对于流结尾位置
异常处理：
	异常类似于将实参传递给函数的方式抛出和捕获。可以传递给非引用形参的(意味着可以复制)
		不存在数组或函数类型的异常。相反，抛出一个数组，转换为指向数组首元素的指针，
		抛出一个函数，转换为指向该函数的指针。
	一般而言，在处理异常的时候，抛出异常的块中的局部存储不存在了。
		因为在处理异常的时候会释放局部存储，所以被抛出的对象就不能再局部存
		储，而是用 throw 表达式初始化一个称为异常对象的特殊对象。异常对象由编
		译器管理，而且保证驻留在可能被激活的任意 catch 都可以访问的空间。这个
		对象由 throw 创建，并被初始化为被抛出的表达式的副本。异常对象将传给对
		应的 catch，并且在完全处理了异常之后撤销。
	抛出指针通常是个坏主意：这要求在对应处理代码存在的任意地方存在指针所指向的对象。
栈展开：
	抛出异常--》暂停函数--》查找匹配的catch子句--》找不到--》调用函数退出--》继续在调用
		该函数的函数中查找。(嵌套函数调用链)。如果最终未找到匹配的catch，调用terminate函数。
	栈展开期间，提早退出包含throw的函数和调用链中可能的其他函数，编译器保证适当地
		撤销或析构局部对象。
	如果一个块直接分配资源，而且在释放资源之前发生异常，在栈展开期间将不会释放该资源。
	重新抛出异常：throw;
		单个catch不能完全处理一个异常时，通过重新抛出将异常传递给函数调用链中更上层的
		函数。
构造函数与函数测试块：
	为了处理来自构造函数初始化式的异常，必须将构造函数编写为函数try块：
	template<class T> H<T>::H(T *p)
	try:ptr(p),use(new size_t(1)){}
	catch(const std::bad_alloc &e)
	{h_out_of_memory(e);}
命名空间：
	可以在全局作用域或其他作用域内部定义，但不能在函数或类内部定义。
	命名空间作用域不能以分号结束。
	命名空间是累积的，可以分散到多个文件中。
	函数名完全限定，则处于命名空间的作用中，形参和函数体可以直接引用作用域内的成员。
	未命名的命名空间定义局部于特定文件，不跨越多个文本文件。
		可以不连续，不能使用域操作符引用，直接使用，如果在最外层作用域中定义，则未命名
		空间中的名字必须与全局作用域中定义的名字不同。
		如果头文件定义了未命名的命名空间，则每个包含该头文件的文件中，该空间定义不同的实体
	using声明：
		在声明作用域内可直接引用命名空间的成员
		只是声明一个名字，而非特定的函数
	内联命名空间：
		inline namespace outer{ namespace inner{} }
		通过外层命名空间可直接访问内层命名空间中的名字，无需再加前缀
	未命名的命名空间：
		仅在特定的文件内部有效，作用于不会跨越多个不同的文件
多重继承下成员X：
	如果在每个路径中X表示同一虚基类成员，则没有二义性，因为共享该成员的单个实例。
	如果在某个路径中X是虚基类的成员，而在另一路径中X是后代派生类的成员，也没有二义性，
		因为特定派生类实例的优先级高于共享虚基类实例
	如果沿每个继承路径X表示后代派生类的不同成员，则该成员的直接访问是二义性的。
	解决二义性可以在本类中设计覆盖实例。
虚基类的构造：必然是首先构造虚基类
			ZOO
		/         \
	  BEAR     RACOON
		\          /
		   PANDA
	由最底层的派生类PANDA直接控制虚基类ZOO的构造。
	然后构造中间派生类BEAR，忽略中间派生类BEAR用于构造虚基类的初始化列表的初始化式
	然后构造RACOON,再次忽略ZOO的初始化式
	最后构造PANDA部分。
控制内存分配：
	若要将对象放置在特定的内存空间中，可以重载new运算符和delete运算符去控制内存分配的过程
优化内存分配：
	new基于每个对象分配内存的事实可能会对某些类强加不可接受的运行时开销，可以通过预先
		分配用于创建新对象的内存，需要时在预先分配的内存中构造每个新对象。
分配和释放未构造的原始内存
	1.allocator类：
		提供可感知类型的内存分配，这个类支持一个抽象接口，以分配内存并随后使用该内存保存对象
	2.标准库中的operator new和operator delete，他们分配和释放需要额定大小的原始的未类型化的内存
在原始内存中构造和撤销对象：
	1.allocator类提供construct和destroy成员，前者在未构造内存中初始化对象，后者在对象上运行
		适当的析构函数
	2.定位new表达式接受指向未构造内存的指针，并在该空间中初始化一个对象或一个数组
	3.可以直接调用对象的析构函数来撤销对象，析构函数不释放对象所在的内存
	4.算法uninitialized_file和uninitialized_copy像fill和copy算法一样执行，除了他们目的地构造对象
		而不是给对象赋值
operator new：库函数
	string * sp=new string("buzhidao");//此处new为运算符
	1.调用operator new的标准库函数，分配足够的内存-》
	2.运行构造函数，初始化-》
	3.返回该对象指针
operator delete：
	delete sp;//此处delete为运算符
	1.对sp指向的对象运行适当的析构函数
	2.调用operator delete标准库函数，释放该对象所用内存
定位new：
	接受指向已分配但未构造内存的指针，并在该内存中初始化一个对象
	new (p) T(t);
	定位new表达式：
	允许向new传递额外的参数
	int *p=new(nothrow) int;//分配失败返回空指针
new表达式:
	调用operator new函数分配内存
	优化new和delete的行为时，只需要定义operator new和operator delete的新版本
自由列表：
	释放元素时，将内存放回预先分配的块中，而不是返回给系统
运行时类型识别：RTTI
	typeid操作符：返回指针或引用所指对象的实际类型
	dynamic_cast操作符：将基类类型的指针或引用安全的转换为派生类型的指针或引用
	对于带虚函数的类，运行时执行RTTI操作符，对于其他类型，在编译时计算RTTI操作符
枚举：
	限定作用域：enum class e1{};使用时加上作用域
	不限定作用域：enum e2{};
类成员指针：
	static成员指针是普通指针
嵌套类：
	只在外层类作用域可见，外层成员可以像使用其他类型成员一样使用嵌套类的名字
	是独立的类，嵌套类的对象不具备外围类所定义的成员，同样，外围类的成员也不具备
		嵌套类所定义的成员。
局部类：
	不能使用函数作用域中的局部变量
------------------Linux下的库------------------------------------------------------------
本质上为可执行代码的二进制格式，可以被装入内存中执行。
分为静态库和动态库
不同：被载入的时刻不同
	静态库在程序编译时被链接到目标代码中，目标程序运行时不再需要该动态库，移植方便但体积大，浪费资源，可执行文件大
	动态库在程序运行时才被载入，可执行文件小。使得程序升级相对简单，比如动态库更新，只需要更换动态链接库文件，不需要更换可执行文件
//包含头文件后，gcc会主动抓取相关的函数库
静态库：
	后缀为.a，在Linux下一般命名为libxxx.a
	优点：可执行文件最终运行时不在需要该库的支持，因为所有使用的函数已经编译进去了
	创建：使用ar 将各个.o文件组合在一起
		（1）编辑源文件（.c或.cpp）
		（2）通过gcc -c xxx.c或g++ -c xxx.cpp生成目标文件(.o)
		（3）用ar归档目标文件，生成静态库（ar [csrtv] libxxx.a xx.o xx1.o ...）常用crs
			c:无论库是否存在，都创建一个库
			s:创建目标文件索引，创建较大库时加快时间
			r:在库中插入模块，同名替换
			t:显示库中目标文件的名称（tv:名称+时间+大小）
		（4）配合静态库写一个头文件，文件里的内容就是提供给外面可以使用的函数、变量或类的声明。
	使用：
		也可以在文件头部extern 想要用到的静态库函数 编译时加上 -L[库文件路径] -lxxx			//-lxxx：自动寻找libxxx.a
动态库：
	又称为共享库，后缀为.so，在Linux下一般命名为libxxx.M.N.so  //M为主版本号，N为副版本号
	默认首先链接同名动态库，找不到再找同名静态库
	创建：
		g++ xxx.c -fPIC -shared -o libxxx.so
		-shared:表示生成共享库
		-fPIC:编译为位置独立的代码，在可执行程序加载的时候可以存在放在内存中的任何位置
	使用：
		可以在文件头部extern 想要用到的静态库函数 编译时加上 -L[库文件路径] -lxxx，但运行时错误：找不到该动态库
		解决方法3种：
		（1）将库复制到/usr/lib和/lib下，运行 ldconfig命令
		（2）在命令前加环境变量，LD_LIBRARY_PATH=[动态库文件路径] ./main
		（3）修改/etc/ld.so.conf文件，将动态库文件路径加到该文件中，然后ldconfig，系统就会把这个路径作为默认路径
------------------ERROR------------------------------------------------------------------
全局变量重定义或是多次定义的：
	只要定义时尽量在.cpp文件中进行，而不要在.h文件中定义，在.h文件中用extern关键字声明，
		否则可能会引起重复定义。
	
	
	


















