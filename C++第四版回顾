在迭代遍历关联容器时,我们可确保按键的顺序访问元素,而与元素在容器中的存放位置完全无关。

用下标访问map中不存在的键值对，会导致在map插入一个新元素，键就是下标，值进行默认初始化。

使用map的带有键值对形参的insert版本返回一个包含一个迭代器和一个bool值得pair对象。
	pair<map<string,int>::iterator,bool> ret = mymap.insert(make_pair('str',111));
	其中itertor指向这个要插入的pair，bool指示是否插入(若map中已有此键，则不插入)。

使用下标得到某个键关联的值，如果键不存在则会插入一个
	为了不插入，可使用count（返回K出现的次数）和find（如果存在返回指向该元素的迭代器，不存在，返回超出末端迭代器）方法。

与 map 容器的操作一样，带有一个键参数的 insert 版本返回 pair 类型对象，包含一个迭代器和一个 bool 值，迭代器指向拥有该键的元素，
	而 bool 值表明是否添加了元素。使用迭代器对的 insert 版本返回 void 类型

在 multimap 中，同一个键所关联的元素必然相邻存放

算法永不执行容器提供的操作，独立于容器，才算泛型

成员函数基于是否const可以形成重载的原因：因为如果只有const函数版本，则非const对象调用一个返回该类引用的const成员函数后返回const对象。
	影响例如，连续调用不可用了。ca.func_const().set(x);

在类体外定义的成员函数的名字需要加上类作用域限定，此后，参数以及类体可直接使用类中的成员
	但成员函数的返回类型不一定在类作用域中。如果返回类型使用由类定义的类型，则必须使用完全限定名。















