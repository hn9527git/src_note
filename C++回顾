在类中定义的成员函数会被当作是内联函数
	在类体外定义的内联成员函数 应该被包含在含有该类定义的头文件中
	内联函数发生上面那种替换是在编译期间，在编译期间编译器为了找到需要找到内联函数的定义，所以在为了方便编译器找到定义，
	每个文件引用头文件后，都直接拥有这种定义，而不用再去写。

而普通函数可以声明和定义分离，主要是编译阶段就不需要函数定义。首先编译阶段找到函数的申明，链接阶段才会去找函数的定义，将之关联起来。 

在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用；
	在函数体内定义的static表示只在该函数体内有效；

c_str()返回const char* 指针指向c风格数组：为了防止字符数组被程序直接处理！！！(可以先复制出来，再进行处理)
	//如果返回char*，而这个属性是类的私有属性，那么就可以通过指针直接修改类的私有属性，多么可怕！！！

容器的元素被初始化为与其类型相关的缺省值 算术和指针类型的缺省值是 0 对于class 类型 
	缺省值可通过调用这类的缺省构造函数获得，也可自己指定

复数complex< double > conjugate[ 2 ] = {
										complex< double >( 2, 3 ),
										complex< double >( 2, -3 )
									};
									complex_obj.real();  ==  real(complex_obj);
									complex_obj.imag();  ==  imag(complex_obj);

对于 multimap 或 multiset  不支持下标操作是访问 multimap 元素的一个限制
	一种迭代策略是联合使用由 find()返回的 iterator 指向第一个实例 和由 count()返回的值，
	更精彩的策略是使用由 multiset 和 multimap 的特殊操作 equal_range()返回的 iterator 对值
	如果这个值存在 则第一个 iterator 指向该值的第一个实例 且第二个 iterator 指向这个值的
	最后实例的下一位置 如果最后的实例是 multiset 的末元素 则第二个 iterator 等于 end()
	vector<int> vi={1,2,3,4,5,6,4,3,2,4,6,3,1,2,4};
    typedef vector<int>::iterator it;
    sort(vi.begin(),vi.end());//需要先排序，否则只能找到第一个或0个
    pair<it,it> pos = equal_range(vi.begin(),vi.end(),4);
    for(;pos.first!=pos.second;pos.first++)
    {
        cout<<*pos.first<<" ";
    }
	equal_range()返回std::pair对象，其first和second成员都成为迭代器，且分别指向输入序列中所有值等于
	val 的元素所组成的子序列的起始及末尾（即最后一个元素之后的位置）位置。
		first 成员的值等同于 std::lower_bound 执行于同一输入序列后的返回。
		second 成员的值等同于 std::upper_bound 执行于同一输入序列后的返回。

将参数声明为数组的引用 当参数是一个数组类型的引用时 数组长度成为参数和实参类型的一部分 
	编译器检查数组实参的长度与在函数参数类型中指定的长度是否匹配
	// 参数为 10 个 int 的数组
	// parameter is a reference to an array of 10 ints
	void putValues( int (&arr)[10] );
	int main() {
		int i, j[ 2 ];
		putValues( i ); // 错误: 实参不是 10 个 int 的数组
		putValues( j ); // 错误: 实参不是 10 个 int 的数组
		return 0;
	}

在某些情况下 编译器自动将按值返回转换到按引用返回 该优化被称为命名返回值优化 named return value optimization 
	返回值优化，是一种属于编译器的技术，它通过转换源代码和对象的创建来加快源代码的执行速度。当函数需要返回一个对象的时候，
	如果自己创建一个临时对象用户返回，那么这个临时对象会消耗一个构造函数（Constructor）的调用、一个复制构造函数的调用（Copy Constructor）
	以及一个析构函数（Destructor）的调用的代价。而如果稍微做一点优化，就可以将成本降低到一个构造函数的代价，这样就省去了一次拷贝构造函数
	的调用和依次析构函数的调用。

将取地址操作符作用在函数名上也能产生指向该函数类型的指针 因此 lexicoCompare和&lexioCompare 类型相同 指向函数的指针可如下被初始化：
	int (*pfi1)( const string &, const string & ) = lexicoCompare;
	int (*pfi2)( const string &, const string & ) = &lexicoCompare;
	因为不带下标操作符的数组名会被解释成指向首元素的指针，！当一个函数名没有被调用操作符修饰时 会被解释成指向该类型函数的指针！。
	在指向函数类型的指针之间不存在隐式类型转换。

指向函数的指针可以被用来调用它所指向的函数 调用函数时 不需要解引用操作符无论是用函数名直接调用函数 
	还是用指针间接调用函数 两者的写法是一样的 。
	int min( int, int );//函数声明可以不带参数名，有类型就行
	int (*pf)( int, int ) = min;
	调用：
		min(1,2);
		pf(1,2);
		(*pf)(1,2);
		
int (*p)[1024] = new int[4][1024];
	在空闲存储区上分配的数组不能给出初始化值集，应在循环中一个一个地初始化。

动态分配数组的主要好处是 它的第一维不必是常量值 即 在编译时刻不需要知道维数 就像局部域或全局域中的定义所引入的数组的维数一样 
	这意味着我们可以分配符合当前程序所需要大小的内存

const int *pci = new const int(1024);//在空闲存储区创建一个const对象
	1、必须初始化，或有默认构造函数。
	2、返回值必须是指向const的指针。
	即使 delete 表达式的操作数是一个指向 const int 的指针 delete 表达式仍然是有效的，并且使 pci 指向的内存被释放

定位new:  预先分配内存返回首地址char *p = new char[1024];   
	使用定位new在预先分配的内存中创建对象
	int* pi = new(p) int(1024);  
	释放内存  delete [] p;
	不需要对应定位new的delete操作，因为内存释放后，它所包含的任何对象的生命期也就都结束了
	如果类型不定，需要额外定义一个指针，每次使用定位new后，将其向后挪相应的空间大小，p++即可，移动单位就是指针类型
	如果仅为了指定的类或其他类型使用定位new，可以使用链表来分割预先分配的内存池，每次取一个

可以抛出枚举类型的异常
	enum EHstate { noErr, zeroOp, negativeOp, severeError };
	int mathFunc( int i ) {
	if ( i == 0 )
	throw zeroOp; // 枚举类型的异常
	// 否则的话 继续正常处理流程

未找到处理异常的代码时，默认调用terminate(),terminate()默认调用abort()。//必要时可以修改terminate()函数的实现。

异常规范 exception specification 提供了一种方案 它能够随着函数声明列出该函数可能抛出的异常 它保证该函数不会抛出任何其他类型的异常
	//对于 pop()的调用 保证不会抛出任何 popOnEmpty 类型之外的异常 
	void pop( int &value ) throw(popOnEmpty);//通过声明直接指定本函数可以抛出的异常

如果函数向上(!!!)抛出了一个没有被列在其异常规范中的异常 则系统调用 C++标准库中定义的函数unexpected()，
	unexpected()的缺省行为是调用 terminate() 

如果函数抛出了一个没有被列在其异常规范中的异常 系统未必就会调用 unexpected() 如果该函数自己处理该异常 
	并且该异常在 逃离 该函数之前被处理掉 那么一切都不会有问题 

extern void no_problem() throw();//保证不会抛出异常
	如果一个函数声明没有指定异常规范 则该函数可以抛出任何类型的异常
	在被抛出的异常类型与异常规范中指定的类型之间不允许类型转换 

函数指针的主要性能缺点是 它的间接引用使其不能被内联。
	//自我理解：函数指针是运行时才知道具体值得变量，所以不能内联
	//或者整一个const函数指针，但这样函数指针又没有了意义，函数指针得意义就在于动态地调用函数
	//又或者编译器被设计为不内联函数指针，尽管它是个const指针。
	对函数指针的替代策略是函数对象：函数对象是一个类 它重载了函数调用操作符 operator() 
	函数对象与函数指针相比较 有两个方面的优点 :
	首先 如果被重载的调用操作符是 inline函数 则编译器能够执行内联编译 提供可能的性能好处 
	其次 函数对象可以拥有任意数目的额外数据(对象的属性) 用这些数据可以缓冲结果 也可以缓冲有助于当前操作的数据

友元声明不受三种成员访问限定符的限制
	一个友元或许是一个名字空间函数 另一个前面定义的类的一个成员函数 也可能是一个完整的类 
	在使一个类成为友元时 友元类的所有成员函数都被给予访问 被授权友谊的类具有访问自己非公有成员的权力 
	类必须将重载函数集中每一个希望设为友元的函数都声明为友元

静态数据成员的类型可以是其所属类 而非static 数据成员只能被声明为该类的对象的指针或引用!!!
	静态数据成员可以被作为类成员函数的缺省实参 而非 static 成员不能
	类外定义静态成员时，不能再加static

函数指针不能被赋值为成员函数的地址 即使返回类型和参数表完全匹配 函数指针存储函数的地址 可以被用来直接调用那个函数
	成员函数指针首先必须被绑定在一个对象或者一个指针上 才能得到被调用对象的 this 指针
	然后才调用指针所指的成员函数 

在数据成员指针和普通指针之间的不匹配也是由于这两种指针的表示上的区别 普通指针含有引用一个对象所需的全部信息 
	数据成员指针在被用来访问数据成员之前 必须先被绑定到一个对象或指针上 

union  一种节省空间的类
	可以使用三种访问限定符
	union 不能有静态数据成员或是引用成员 如果一个类类型定义了构造函数 析构函数或拷贝赋值操作符 则它不能成为 union 的成员类型 
	可以为 union 定义成员函数 包括构造函数和析构函数
	为了防止对union的错误访问，一般定义一个额外的判别式来追踪被存储在union中的值的类型。

私有成员是指这样的成员 它只能在该类的成员或友元定义中被访问 除非外围类被声明为嵌套类的友元 否则它没有权利访问嵌套类的私有成员 
	嵌套类也没有任何特权访问其外围类的私有成员 

嵌套类不能直接访问其外围类的非静态成员 即使这些成员是公有的 任何对外围类的非静态成员的访问都要求通过外围类的指针 引用或对象来完成 

嵌套类可以直接访问外围类的静态成员 类型名 枚举值 假定这些成员是公有的 类型名是一个typedef 名字 枚举类型名 或是一个类名 

缺省构造函数是指不需要用户指定实参就能够被调用的构造函数 这并不意味着它不能接受实参 只意味着构造函数的每个参数
	都有一个缺省值与之关联

如果一个类提供了两个分别被称为操作符 new()和操作符 delete()的成员函数 那么它就可以承接自己的内存管理权
	如果在类中定义了这些成员操作符 则它们会被调用 以取代全局操作符来分配和释放该类类型的对象 
	例：当 new 表达式创建一个类类型的对象时 编译器查看该类是否有一个成员操作符 new()
	如果有 则选择这个操作符为该类对象分配内存 否则 调用全局操作符 new() 例如 下面的 new 表达式
		Screen *ps = new Screen;
	//不管默认的还是自己提供的操作符 new()和操作符 delete()的成员函数，调用结束时自动调用构造函数，
	//如果在自己提供的函数内部调用默认的new或delete，会调用两次构造函数

类成员操作符 new()和 delete()默认都是类的静态 static 成员 它们遵从静态成员函数的一般限制这些操作符被自动做成静态成员函数
 	而无需程序员显式地把它们声明为静态的 尤其要记住的是静态成员函数没有 this 指针 因此它们只能访问静态数据成员
 	其原因是： 这些操作符被调用的时候 要么是在该类对象被创建之前//操作符 new(),要么是在其被销毁之后//操作符 delete()

类成员操作符 new()的返回类型必须是void*  //成员数组new的返回类型也必须是void*
	1、类成员操作符 new()的返回类型必须是 void*型 并且有一个 size_t 类型的参数     //
	2、类成员操作符 delete()的返回类型必须是 void 并且第一个参数的类型是 void*     //
		为一个类类型而定义的 delete()操作符 如果它是被 delete 表达式调用的 则它可以有两个参数而不是一个 
		第一个参数仍然必须是 void*型 而第二个参数必须是预定义类型 size_t
		如果还存在额外的参数 则它将被编译器用第一个参数所指对象的字节大小自动初始化!!!
		void operator delete( void *p, size_t ss);//ss被初始化为p指向的对象的大小。
	1、类成员操作符new[]()的返回类型必须是 void* 并且第一个参数的类型是 size_t     //void *operator new[]( size_t );
	2、成员操作符 delete[]()的返回类型必须是 void 它的第一个参数必须是 void*类型   //void operator delete[]( void* );
		一个类的操作符 delete[]()也可以有两个参数 第二个参数的类型是预定义类型 size_t
		如果存在额外的参数 则它由编译器自动初始化 其值等于存贮数组所需内存的字节大小
		void operator delete[]( void*, size_t );

只要每个声明都有惟一的参数表 我们也可以重载类的成员操作符 new() 但是任何一个类操作符 new()的第一个参数的类型都必须是 size_t 
	class Screen {
			public:
			void *operator new( size_t );
			void *operator new( size_t, Screen* );
			// ...
		};
		额外的参数可以被 new 表达式中指定的定位实参初始化 例如
		void func( Screen *start ) {
			Screen *ps = new (start) Screen;//start自动传递给第二个参数
			//1 调用类 Screen 的操作符 new(size_t, Screen*)
			//2 接着 调用类 Screen 的缺省构造函数在start处初始化该对象
			//3 然后 用 Screen 对象的地址初始化 ps
		}
		//如果 Screen 类的缺省构造函数抛出一个异常并退出 则编译器会在 Screen 类的域中查找一个操作符 delete() 
			要想使操作符 delete()被考虑 它必须具有与被调用的 new()操作符的参数类型相匹配的参数 
		//如果说操作符 new()分配了内存 则应该提供相应操作符 delete() 以便当 new 表达式调用的构造函数抛出异常时可以正确地释放内存
			如果定位操作符 new()没有分配内存 则无需提供相匹配的操作符 delete()来释放内存

函数对象和函数指针的对比：
	（1）函数对象有自己的状态，即它可以携带自己的成员函数，而且这个函数对象在多次调用的过程中它的那些状态是共享的，
		 而函数则不能做到这点（除非定义函数内部的静态变量或者全局变量）。
	（2）函数对象有自己的类型，而普通函数则没有。在使用STL的容器时可以将函数对象的类型传递给容器作为参数来实例化相应的模板，
		 从而来定制自己的算法，如排序算法。//即写一个模板函数对象类。
	（3）可以用（而且提倡、建议）函数对象来代替函数指针  。函数对象可以在内部修改而不用改动外部接口
	    （1）函数对象通过重载()实现，那么将operator()函数设置为内联函数，可以提高程序的运行速度。如上面的例子，
	    	相比于传入greaterNum函数指针为sort的第三个形参，传入是GreaterNum<int>函数子时，程序运行的速度快。
	    	因为内联函数在编译时展开，而函数指针要进行调用。
	    （2）函数对象可以携带附加信息，如类的其他数据成员，而函数指针则做不到。

cin的get()函数有三种形式
	1、cin.get(char &ch);//从输入流中提取一个字符，包括空白符，存在ch中,返回istream对象
	2、cin.get();//他返回该字符值，而不是istream对象，返回int，而不是char，文件为标志为-1
		//while((i=cin.get()) && i!=EOF)
	3、get(char *sink, streamsize size, char delimiter='\n')
		sink 代表一个字符数组 用来存放被读取到的字符 size 代表可以从 istream 中读入的字
		符的最大数目 delimiter 表示 如果遇到它就结束读取字符的动作 delimiter 字符本身不会
		被读入 而是留在 istream 中 作为 istream 的下一个字符 一种常见的错误是 在执行第二
		个 get()之前忘了去掉 delimiter //cin.ignore();

cin.getline(c,3,'\n');//第三个参数为结束符，默认为换行

输入输出到文件
	ofstream outfile( "copy.out", ios_base::out );
		//默认为输出模式out，可以改为附加模式app
	ifstream infile( "alice_emma" );
		//使用流迭代器
		istream_iterator<string> ifile( infile );
		istream_iterator<string> eos;
		vector< string > text;
		copy( ifile, eos, inserter( text, text.begin() ));
		ostream_iterator<string> ofile( infile );
		copy(ifile, eos, ofile);

在迭代遍历关联容器时,我们可确保按键的顺序访问元素,而与元素在容器中的存放位置完全无关。

用下标访问map中不存在的键值对，会导致在map插入一个新元素，键就是下标，值进行默认初始化。
	为了不插入，可使用count（返回K出现的次数）和find（如果存在返回指向该元素的迭代器，不存在，返回超出末端迭代器）方法。

使用map的带有键值对形参的insert版本返回一个包含一个迭代器和一个bool值的pair对象。
	pair<map<string,int>::iterator,bool> ret = mymap.insert(make_pair('str',111));
	其中itertor指向这个要插入的pair，bool指示是否插入(若map中已有此键，则不插入)。

在 multimap 中，同一个键所关联的元素必然相邻存放

算法永不执行容器提供的操作，独立于容器，才算泛型

作为STL容器元素需要满足的条件：
	（1）可默认构造的，即具有public的default constructor,不论用户显式定义的还是编译器默认的（不是所有容器都需要的）；
	（2）可拷贝构造（Copy Constructible）和拷贝赋值（Copy Assignable）的，即具有public的copy constructor和copy assignment  
	     operator,不论是编译器默认的，还是用户显式定义的（即元素必须是可拷贝的，但实际上拷贝赋值的要求不是强制的，和条件1类似）；
	（3）具有public的destructor，编译器默认的用户显式定义的都可以；
	（4）对于关联式容器，要求其元素必须是可比较的。













