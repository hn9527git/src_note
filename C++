类的三种权限：
	public、protected、private
	对于本类内部，三种标号都能访问。
	对于公有继承，派生类可访问原属基类的public和protected成员。
	对于保护继承，基类的public和protected成员在派生类中都成为protected成员，派生类可访问原属基类的public和protected成员。
	对于私有继承，基类的public和protected成员在派生类中都成为private成员，派生类可访问原属基类的public和protected成员。
注意：重载=操作符时：
	应返回*this的引用：HN& operator=(const HN&);s
	如果返回void，将会导致不能使用类似 hn1=hn2=hn3;的连等的形式的使用。
	应先检查是否是自赋值，因为被赋值的对象会先释放资源，再去根据新值分配新的资源。
虚函数表指针：
	只有当类中含有虚拟函数时才会生成。(一个不会被继承的类的析构函数不需要是虚拟的，所以没有虚函数表指针)。
	如果一个派生类的基类的析构函数不是虚函数，又通过指向派生类的基类指针去释放空间，
	会导致未定义的行为(一般的情况就是派生类的析构函数永远也不会被调用，因为析构函数不是虚函数，而指针又是基类指针，
	当然只会调用基类的析构函数咯)。
	虚函数表是类的属性，虚函数表指针是对象的属性，每个对象的虚函数表指针值是一样的，都指向共同的虚表。
	普通函数不能使用virtual声明，编译会报错
三法则：//如果需要其中一个，那么也就需要其他两个
	析构函数、复制构造函数、赋值操作符函数
拷贝构造函数和赋值运算符区别：
	行为比较相似，却产生不同的结果；拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。
	区分是调用拷贝构造函数还是赋值运算符，主要看是否有新的对象产生。
volatile：
	当可以用编译器的控制或检测之外的方式改变对象值的时候，当声明为volatile，给编译器
		的指示是这样的对象不应该执行优化（比如放在寄存器中）。而应给其存储空间，每次去实际地址取值，而不是寄存器。
		禁止编译器可能的优化行为(将经常用的变量自动放在寄存器中)
sig_atomic_t:
   当把变量声明为该类型是，则会保证该变量在使用或赋值时， 无论是在32位还是64位的机器上都能保证操作是原子的， 它会根据机器的类型自动适应
restrict:
	C语言中的一种类型限定符（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的
	方式修改该对象的内容。
explicit:
	抑制由构造函数定义的隐式转换；只能用在类内部的构造函数声明上。外部定义时不再重复它。
	除非有明显理由要定义隐式转换，否则单形参构造函数应该定义为explicit，若有转换需要，还可以显式使用构造函数来转换。
	声明后，该类构造函数只能用于直接初始化A item(string)
	而不能使用拷贝初始化A item2=string;
缺省情况下 单参数构造函数(或者有多个参数 除了第一个参数外 其他都有缺省实参)被用作转换操作符 
	// 在某个头文件中
	extern void print( const Account &acct );
	// ...
	int main()
	{
		// 把 "oops" 转换成一个 Account 对象
		// 用 Account::Account( "oops", 0.0 )
		print( "oops" );
		// ...
	}
	无意的隐式类转换 如把 oops 转换成一个 Account 对象 已经被证明是很难跟踪的错误源 
	关键字 explicit 被引入到标准 C++中 以帮助我们抑制这种不受欢迎的编译器辅助行为
	explicit 修饰符通知编译器不要提供隐式转换
	class Account{public: explicit Account( const char*, double=0.0 );...};
为防止使用该构造函数进行隐式类型转换 我们可以把它声明为显式的explicit
	但是 该构造函数仍然可以被用来执行类型转换 只要程序以强制转换的形式显式地要求转换即可//func( static_cast< Number >( si ) );
extern "C"
	必须出现在函数的第一次声明上，extern "C" 函数
	编译器按照处理C语言的方式处理代码
		extern “C” double calc(){};
		C语言不支持重载
链接指示符只能指定重载函数集中的一个函数
	// 错误: 在一个重载函数集中有两个 extern "C" 函数
	extern "C" void print( const char* );
	extern "C" void print( int );
	每个重载函数都有一个唯一的内部名编码：例如将参数类型和个数编码成函数名的一部分
	这种特殊编码不适用于用链接指示符 extern "C"声明的函数 这就是为什么在重载函数集合中只有一个函数
	extern "C"的函数会被链接编辑器视为同一函数//这就是为什么C语言不支持重载函数的原因
指向 C 函数的指针不能用指向 C++函数的指针初始化或赋值 反之亦然 否则 就会产生编译错误 
	再次说明 在 C 函数指针与 C++函数指针有相同特性的编译器实现中 编译器可能会支持一种语言扩展 允许向 f1()传递一个
	 C++函数指针作为实参
extern int a;//在某个头文件中声明
	声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块(文件)中使用，
	记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用A模块(编译单元)中定义的全局变量或函数时，
	它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，
	但它不会报错，它会在链接时从模块A生成的目标代码中(.o文件)找到此变量或函数
声明与定义：//分离式编译
	extern int a;//可以声明多次，但只能定义一次，使用时需要包含定义该变量的文件，
	只告诉编译器类型和名字
	int a;//定义，分配了存储空间，可以给一个初始值
#pragma once
    这个的做用就是防止头文件多次包含//
    	由编译器提供保证：同一个文件不会被编译多次。注意这里所说的“同一个文件”
    	是指物理上的一个文件，而不是指内容相同的两个文件。
   	另一种方法使用//C++常用这种方式
   	#ifndef xx.h 
   	#define xx.h  
   		内容
   	#endif 
assert预处理宏：
	assert(表达式);//为假，输出信息并终止程序，为真，则什么也不做
	//关闭：需要在包含头文件的上边定义NDEBUG，或在命令行中指定宏NDEBUG，或在make文件中定义
		#define NDEBUG
		#include <assert.h>
正负数内存表示：//都存储的补码
	正数：正数补码就是本身
	负数：负数的补码就是相应正数按位取反后加一
宽字符：wchar_t
	L"中国"
初始化和赋值不同：
	初始化是创建时给予一个值
	赋值是擦除当前变量，用新值替代
列表初始化：
	C++11标准中规定如果使用初始化列表且初始值存在丢失信息的风险时
	(例如将double赋值给int//int i{d})，编译器报错
void *指针：
	没办法访问内存空间，只能与其他指针比较，作为函数输入输出，或者赋值给void*指针
const:
	仅在文件内有效，不同文件的同名const变量属于分别定义了独立的变量
	要想共享的解决办法：不管声明还是定义都加上extern即可。
	预处理编译和汇编不需要其值，链接时需要其生成的.o目标文件
顶层const:
	表示指针本身是一个常量
	不能作为普通重载函数的区别
底层const://指针本身可以变，但不能通过该指针修改所指或所引的值
	表示所指的对象是一个常量
	//用于声明引用的都是底层const
	//拷出拷入对象必须具有相同的底层const资格，或者数据类型可以转换
	//对常量取地址是一个底层const
	//对变量取地址是一个顶层const，例如int a=1;//&a 则a的类型为 int*const
类型别名：
	typedef 定义以关键字 typedef 开始 后面是数据类型和标识符。
	typedef char * p;
	const p cp=0;//cp是一个指向char的常量指针
	//替换理解是错误的，const和char *都是修饰cp的，即char* const cp = 0;
别名声明：
	using Si=Sales_item
字面值和string相加：//二者不同
	必须保证每个加号的两侧对象至少有一个是string
建议：使用C++版本的C标准库头文件
	C：  name       //不一定属于std
	C++: cname		//定义的名字从属于std
引用：
	不是对象，不存在包含引用的vector或数组
引用的大小：
	在类和结构体里，引用和指针的大小是一样的。
	对于基本类型，引用的大小就是所引用的对象的大小。
数组指针：
	char a[6];
	auto a1(a); 发生转换，相当于 a1(&a[0]) //a1是char *
	decltype(a) a2;不发生转换，a2是一个包含六个char的数组
	也可以使用begin()和end()获取首指针和尾指针(不是成员函数)
数组初始化：
	char a[10] ={0};
	//如果大括号内提供的初值个数(即字符个数)大于数组长度,则编译时将出错.
	//如果初值个数小于数组长度,则只将这些字符赋给前面的数组元素,其余的元素自动赋空字符(即'/0')
C风格字符串：不建议使用
	以空字符结束，一般利用指针来操作这些字符串，如果末尾不加空字符，其很多方法都不能正确使用，引发溢出错误
左值和右值：
	当一个对象被用作右值时，用的是对象的内容
	当被用作左值时，用的时对象的身份(内存地址)
转换：
	static_cast<to>(from)
		不包含底层const可以使用，告诉编译器不在乎精度损失
	const_cast<to>(from)
		只能改变运算对象的底层const
	reinterpret_cast<to>(from)
		为运算对象的位模式提供较低层次上的重新解释
		//例如将int *转换为char*
	dynamic_cast<to>(from)
		运行时识别
try:
	try块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问
标准异常：
	exception:只报告异常的发生，不提供任何额外信息
	domain:逻辑错误，参数对应的结果值不存在
	invalid_argument:逻辑错误，无效参数
标准异常类层次：
						exception
	---------------------------------------------------------
	|	            |                  |                     |
bad_cast        runtime_error       logic_error          bad_alloc
			--------------------  ---------------------		
			1.overflow_error       1.domain_error
			2.underflow_error      2.invalid_argument
			3.range_error		   3.out_of_range
								   4.length_error
what()函数：
	异常类定义，返回一个c风格字符串，提供异常信息(指定或默认)
析构函数不应该抛出异常：
	若有异常，应在析构函数内部使用try catch在内部解决
	若抛出了异常，而且析构函数本身没有捕获到该异常，则程序被终止
catch(...):
	捕获所有异常，放在最后
构造函数中也可以使用try  catch：
	Blob() try : data(new string("wc")) {} catch(bad_alloc &e){处理异常;}
set-new-handler函数
	当内存分配请求不能满足时，调用你预先指定的一个出错处理函数。这个方法基于
	一个常规，即当 operator new 不能满足请求时，会在抛出异常之前调用客户指
	定的一个出错处理函数——一般称为 new-handler 函数。

	指定出错处理函数时要用到 set_new_handler 函数，它在头文件<new>里
	大致是象下面这样定义的：
	typedef void (*new_handler)();
	new_handler set_new_handler(new_handler p) throw();

	可以看到，new_handler 是一个自定义的函数指针类型，它指向一个没有
	输入参数也没有返回值的函数。 set_new_handler 则是一个输入并返回
	new_handler类型的函数。

	set_new_handler 的输入参数是 operator new 分配内存失败时要调用的出
	错处理函数的指针，返回值是 set_new_handler 没调用之前就已经在起作用的
	旧的出错处理函数的指针。

	可以像下面这样使用 set_new_handler：
	// function to call if operator new can't allocate enough memory
	void noMoreMemory()
	{
	 cerr << "Unable to satisfy request for memory\n";
	abort();
	}
	int main()
	{
	set_new_handler(noMoreMemory);
	int *pBigDataArray = new int[100000000];
	...
	}

	假如 operator new不能为 100,000,000 个整数分配空间，noMoreMemory
	将会被调用，程序发出一条出错信息后终止。这就比简单地让系统内核产生错
	误信息来结束程序要好。

	operator new不能满足内存分配请求时，new-handler 函数不只调用一次，
	而是不断重复，直至找到足够的内存。//但例子中直接调用abort退出。

一个设计得好的 new-handler 函数必须实现下面功能中的一种：
	1.产生更多的可用内存。这将使 operator new下一次分配内存的尝试有可能
	获得成功。实施这一策略的一个方法是：在程序启动时分配一个大的内存块，
	然后在第一次调用 new-handler 时释放。释放时伴随着一些对用户的警告信息，
	如内存数量太少，下次请求可能会失败，除非又有更多的可用空间。

	2.安装另一个不同的 new-handler 函数。如果当前的 new-handler 函数不能
	产生更多的可用内存，可能它会知道另一个 new-handler 函数可以提供更多的
	资源。这样的话，当前的 new-handler 可以安装另一个 new-handler 来取代它(通
	过调用 set_new_handler)。下一次 operator new调用 new-handler 时，会使用
	最近安装的那个。(这一策略的另一个变通办法是让 new-handler 可以改变它自
	己的运行行为，那么下次调用时，它将做不同的事。方法是使 new-handler 可
	以修改那些影响它自身行为的静态或全局数据。)

	3.卸除 new-handler。也就是传递空指针给 set_new_handler。没有安装 new-handler，
	operator new 分配内存不成功时就会抛出一个标准的 std::bad_alloc
	类型的异常。

	4.抛出 std::bad_alloc 或从 std::bad_alloc 继承的其他类型的异常。这样的异
	常不会被 operator new捕捉，所以它们会被送到最初进行内存请求的地方。(抛
	出别的不同类型的异常会违反 operator new异常规范。规范中的缺省行为是调
	用abort，所以new-handler要抛出一个异常时，一定要确信它是从std::bad_alloc
	继承来的。

	5.没有返回。典型做法是调用 abort 或 exit。abort/exit 可以在标准 C/C++ 库中找到
类的常量对象：
	以及常量对象的引用或指针都只能调用常量成员函数
类的编译：
	首先编译成员的声明，然后成员函数体，所以成员函数可以随意使用类的其他成员
	而无需在意这些成员的出现次序
类作用域：
	在类体外定义的成员函数的名字需要加上类作用域限定，此后，参数以及函数体可直接使用类中的成员
		但成员函数的返回类型不一定在类作用域中。如果返回类型使用由类定义的类型，则必须使用完全限定名。
	如同类成员函数的定义可以引用类的私有成员一样 静态数据成员的定义也可以 
		例如：static const int MyClass::nameArray[nameSize]="wocao";//nameArray和nameSize属于MyClass的私有数据成员
静态成员：
	外部定义时，无需重复指定static保留字，该保留字只出现在声明处；
	static函数没有this指针；
		因为static成员函数是类的组成部分但不是任何对象的组成部分，没有this指针(const、volatile修饰this)，所以也不能被声明为const，
		也不能被声明为虚函数(需要一个对象)，也不能被声明为volatile，也不能访问类的非静态成员；
	static数据成员必须在类定义体的外部定义正好一次；他不是通过类构造函数进行初始化，而应该在定义时进行初始化；
		-- 类的数据成员不能在类定义体中初始化，例外：只要初始化式是一个常量表达式，
		-- const static数据成员就可以在类的定义体中进行初始化，const static数据成员
		-- 在类的定义体中初始化时，该数据成员仍必须在类的定义体之外进行定义，若在类内部提供初始化式时，成员的定义不必再指定初始值；
		-- const static数据成员的类型可以是该成员所属的类类型(不完全类型)。
		-- const static数据成员可用作默认实参
		//如果static const成员变量没在类体外部定义，加入程序没用到则编译不报错，否则编译报错
类内初始值：
	//只有static const可以在类内初始化，但还需要在类定义体之外定义一次，且不必再指定初始值
	//测试在C++98 和 C++11下不在类定义体之外定义，也没报错
	必须以符号=或者花括号表示
	默认构造函数用它来初始化成员，若没有类内初始值，执行默认初始化该成员
	建议使用，防止const或引用类型未初始化可能引发的错误
	要么使用花括号，要么使用等号，不能使用圆括号//语义分析有歧义，可能被当作函数
可变数据成员：
	mutable a=10;
	永远不会是const，即使它是const对象的成员也可以修改
const成员函数：
	const修饰this
	从const成员函数返回*this，那么它的返回类型是const引用!!!，声明和定义都要加上const关键字修饰
缓冲刷新：
	· 程序正常结束
	· 缓冲区满了
	· 使用操纵符endl：换行并刷新
			   flush：刷新缓冲但不输出任何字符
			    ends：向缓冲区插入一个空字符后，刷新缓冲//测试不出来
	· 使用unitbuf设置流得内部状态，来清空缓冲区
			cout<<unitbuf;//所有输出操作立即刷新
			cout<<nounitbuf;//回到正常缓冲
	· 一个输出流关联到另一个流。当读写关联的流时，被关联的流的缓冲区会被刷新
		默认cin和cerr都被关联到cout，所以读写cin和cerr都会刷新cout的缓冲区
		cin.tie(&cout);//标准库将cin和cout关联
文件模式：
	每个流都有一个关联的文件模式，用来指出如何使用文件
	in 		读方式打开
	out 	写方式打开//现有内容被丢弃
	app 	每次操作前定位到文件末尾
	ate 	打开文件后立即定位到文件末尾
	trunc 	截断文件
	binary 	以二进制方式IO
	例：ofstream out;
		out.open("a.txt",ofstream::app)
swap:
	元素不会被移动，除string外，指向容器的迭代器、引用和指针不会失效
	//因为string可能会被存储在栈上
	标准array使用swap时会真正交换元素
insert:
	将元素插入到迭代器所指定位置之前
	vector不支持push_front，但可以使用insert
emplace_front\emplace\emplace_back
	这些操作构造而不是拷贝元素，调用时将参数传递给元素类型的构造函数
	struct Foo {
    Foo(int n, double x);
	};
	//避免产生不必要的临时变量，将参数直接送给元素类型(在这里是类类型Foo)的构造函数
	std::vector<Foo> v;
	v.emplace(Iterator_to_pos, 42, 3.1416);        // 没有临时变量产生
	v.insert(Iterator_to_pos, Foo(42, 3.1416));    // 需要产生一个临时变量
	v.insert(Iterator_to_pos, {42, 3.1416});       // 需要产生一个临时变量
at：
	容器下标操作可能越界造成运行时错误，使用at函数可以确保下标合法
stod:
	将string转换为浮点值(string中第一个非空白字符必须是数值中可能出现的字符[+-.0-9])
关联容器：
	有序：//stl，底层红黑树
		map:键值对
		set:只保存关键字
		multimap:可重复map
		multiset:可重复set
	无序：//boost
		unordered_map:哈希函数组织的map
		unordered_set:哈希函数组织的set
		unordered_multimap：同上且可重复
		unordered_multiset：同上且可重复
加括号区别：
	int * p=new int;  //p指向未初始化的int
	int * q=new int();//p指向值初始化为0的int
	只对内置类型有差异
	对定义了构造函数的类来说，不管采用了什么形式，对象都会通过默认构造函数来初始化
使用默认构造函数：
	A item();//错误，声明了一个函数而非对象，hh，对内置类型无所谓
	A item;//使用了默认构造函数的一个对象
临时对象：
	生存期，该表达式的末尾;
		例如：  string str1="this is string";
    			const string *p=&str1.substr(8).erase(1);
   				cout<<p<<""<<*p<<endl;
			再去使用p指向的空间时，其上临时对象已经被销毁
			//应声明一个变量，用临时变量赋值
空悬指针：
	指向一块曾经保存数据对象但是现在已经是无效的内存的指针
	在 delete表达式之后 pi 被称作空悬指针 即指向无效内存的指针 空悬指针是程序错误的一个根源它很难被检测到 
	一个比较好的办法是在指针指向的对象被释放后 将该指针设置为 0 这样可以清楚地表明该指针不再指向任何对象
	如果指针操作数被设置为 0 则 C++会保证 delete 表达式不会调用操作符delete() 没有必要测试其是否为 0 实际上 在多数实现下 
	如果增加了指针的显式测试，那么该测试实际上会被执行两次
野指针：
	未经初始化的指针
动态数组：//并非数组类型
	使用容器的类可以使用默认版本的拷贝、赋值、和析构操作
	分配动态数组的类则必须定义自己版本的操作，在拷贝、赋值、和析构中管理所关联的内存
	new分配对象数组：
			int * p=new int[size];//p指向第一个int
		或：typedef int a[42];
			int *q=new a;
	    返回一个数组元素类型的指针，指向第一个元素
	释放：
		delete p;//p必须指向一个动态分配的对象或为空
		delete [] pa;//pa必须指向一个动态分配的数组或为空，数组中元素逆序销毁
delete时是怎么知道到底有多少个对象的？
	因为new[]的时候会在返回的指针的前一个位置中存储数组到底有多少个元素
	delete时只需要根据传入的指针向前取一下这个值就可以了
重载overload
	overload是重载，一般是在一个类实现若干重载的方法，
	这些方法的名称相同而参数形式不同。但是不能靠返回类型来判断。
	顶层const不构成重载
	重载需要注意：
    		位于同一个作用域中
    		函数的名字必须相同
    		形参列表不同
		基于成员函数是否为const，也可以重载
    	若一个重载版本的函数前面有virtual修饰，则表示他是虚函数，但他也是属于重载的一个版本
    		不同的构造函数(无参构造、有参构造、拷贝构造）是重载的应用
	函数的返回类型和缺省值不足以区分两个重载函数
	如果在两个函数的参数表中 只有缺省实参的缺省值不同 则第二个声明被视为第一个的重复声明 
	当参数类型是 const 或 volatile 时 在识别函数声明是否相同时 并不考虑 const 和volatile 修饰符 .
	但是 如果把 const 或 volatile 应用在指针或引用参数指向的类型上 则在判断函数声明是否相同时 
	就要考虑 const 和 volatile 修饰符//即当参数是引用或指针是，是否const和是否volatile也构成重载
	成员函数基于是否const可以形成重载的原因：因为如果只有const函数版本，则非const对象调用一个返回该类引用的const成员函数后返回const对象。
	影响例如，连续调用不可用了。ca.func_const().set(x);
		// 声明了不同的函数
			void f( int* );
			void f( const int* );
		// 也声明了不同的函数
			void f( int * );
			void f( int volatile* );
	成员函数重载：
	只能重载本类的其他成员函数。类的成员函数与普通的非成员函数以及在其他类中声明的函数不相关，也不能重载它们。
	using 声明把基类中每个被命名的成员都引入到派生类的域中 现在 基类成员就可以进入到 与派生类中的成员函数名字相关 的重载实例集中 
	针对一个成员函数的using 声明不能指定参数表 只能指定成员函数名 这意味着 如果该函数在基类中被重载则所有的重载实例都被加入
	到派生类类型的域中 我们不能只增加基类的重载成员函数集中的一个实例
		using 父类::成员函数名;
    匹配：//按顺序寻找
    	1.精确匹配
    	2.const转换匹配
    	3.类型提升匹配
    	4.算术类型转换或指针转换匹配
    	5.类类型转换匹配
重写（覆盖）override
	override是重写（覆盖）了一个方法，以实现不同的功能。一般用于子类在继承父类时，重写（覆盖）
		父类中的方法。函数特征相同，但是具体实现不同。
	重写需要注意：
		被重写的函数不能是static的，必须是virtual的！
		重写函数必须有相同的类型，名称和参数列表,返回类型也必须与基类函数匹配，但有一个例外：
			当类的虚函数返回类本身的指针或引用时，派生类虚函数可以返回自己的引用或指针
		重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public、protect也是可以的
重定义(隐藏)redefining
	派生类对基类的成员函数重新定义，即派生类定义了某个函数，该函数的名字与基类中函数名字一样。
	重定义也叫做隐藏，子类重定义父类中有相同名称的函数（参数可以不同），static静态函数也可以被隐藏
	如果一个类，存在和父类相同的函数，那么这个类将会覆盖其父类的方法，除非你在调用的时候，强制转换为父类类型，
		否则试图对子类和父类做类似重载的调用时不能成功的。
	重定义需要注意：
    		不在同一个作用域（分别位于基类、派生类）
    	函数的名字必须相同
    	对函数的返回值、形参列表无要求
    	若派生类定义该函数与基类的成员函数完全一样（返回值、形参列表均相同），且基类的该函数
    	为virtual，则属于派生类重写基类的虚函数，不是重定义！
多态polymorphism
　　多态的概念比较复杂，一种不严谨的说法是：继承是子类使用父类的方法，而多态是父类使用子类的方法。
　　一般我们使用多态是为了避免在父类里大量重载引起代码臃肿且难于维护。
　　多态分为两类：静态多态性和动态多态性，函数重载和运算符重载实现的多态性属于静态多态性，
	在程序编译时系统就能决定调用哪个函数，因此静态多态性又称为编译时的多态性。
	静态多态性是通过函数的重载实现的。
	动态多态性是在程序运行过程中才动态地确定操作所针对的对象。它又称运行时的多态性。
	动态多态性是通过虚函数实现的。
不用虚函数实现多态：
	在基类中声明一个函数指针print，将实际实现放在另一个静态函数test中，在构造函数中将test赋值给函数指针print
	在派生类中也将实际实现放在另一个静态函数test中，在构造函数中将test赋值给函数指针print
	在使用基类引用或指针调用print时就会根据对象的真实类型调用对应的实现函数
	//为什么需要实际实现函数是静态的，因为要在构造函数中将其赋值给成员函数指针，而且静态函数属于类不属于对象
动态绑定：
	只有通过基类的引用或指针调用虚函数(传给基类的引用或指针参数)，才会发生动态绑定：即运行时绑定
不完整类型：
	在声明之后，定义之前，是一个不完整类型，不能定义该类型的的对象，只能定义指向该类型的指针以及引用，
	或者用于声明使用该类型作为形参类型或返回类型的函数；例如定义链表类时或单例类；
this指针：
	在普通非CONST成员函数中，是一个指向类类型的const指针，在const成员函数中是一个指向
		const类类型对象的const指针；
大小端：
	大端模式，是指数据的高字节保存在内存的低地址中，
		而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作
		字符串顺序处理：地址由小向大增加，而数据从高位往低位放；
	小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，
		这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。
类成员作用域：
	不仅要考虑在本类<定义>之前的全局作用域中的[声明]，而且要考虑在成员函数<定义>之前出现的
	全局作用域[声明]。
类型名：
	如果类成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字，所以类型名的定义通常放在类的开始处。
	原因：
	对类的成员函数体的决议发生在类的生命结束之后，即发现类的右大括号。
	而对类的成员函数的参数列表则在遇到时就适当地决议(其类型)，所以C++ primer中说到：
	要想在类中使用(重新定义)其本身声明前就已经定义的类型，必须将其放在类的开始处
	//反正放在要用到的地方的上边，而不能像数据成员一样可以放在使用它的成员函数的后面！
初始化：
	在局部作用域中内置类型成员不被初始化，在全局作用域中他们被初始化为0；
初始化列表：
	先于花括号内的初始化操作执行
	<只能初始化，不能复制>
	以下不管是哪种类型，都在构造函数初始化列表中或提供类内初始值进行初始化;
	1.初始化引用
	2.初始化const成员
	3.当调用一个基类的构造函数，而它拥有一组参数
	4.当调用一个成员类对象的构造函数，而它拥有一组参数
	对于基本类型，除了const和引用(必须使用初始化表)，使用成员初始化表和在构造函数内部初始化在结果和性能上都是等价的。
初始化次序：
	就是定义成员的次序，不是初始化列表中的次序。
直接初始化和复制初始化：
	复制初始化使用 = 符号，而直接初始化将初始化式放在圆括号中。
类成员的初始化和赋值：
	如果没有在构造函数的初始化列表中显示地初始化成员，则该成员将在构造函数体之前执行默认初始化
声明对象和new对象的区别：
	new出来的对象是直接放在堆上，而声明一个对象是放在栈中。
	声明的作用域限制在定义类对象的方法中，当方法结束时，类对象也被系统释放了，（安全不会造成内存系统泄漏）。
	new 创建的是指向类对象的指针，作用域变成了全局，当程序结束时，必须用delete删除，系统不会自动释放，（不注意可能造成内存泄漏）
显式初始化：==不建议、不要使用！！！
	对于没有定义构造函数！！！并且其全体数据均为public的类
	(就像一个普通的struct)，可以采用与初始化数组元素相同的方式初始化其成员。
	struct/class A
	{
		int a;double b,char c;
	}
	A a = { 6,6,6 };//按次序声明成员
复制构造函数：
	具有单个形参，该形参(常用const修饰)必须是对该类类型的引用，或任何额外参数都有默认值
	·显式使用：当定义一个新对象并用一个同类型的对象对它进行初始化时。
	·隐式使用：当将该类型的对象传递给函数或函数返回该对象类型的对象时。
	直接初始化：将初始化式放在圆括号中。-》直接调用实参匹配的构造函数。
	复制初始化：使用=符号。-》创建临时对象——》复制到正在创建的对象
	-- 形参与返回值：为类类型时，使用复制构造函数进行复制
	-- 初始化容器元素：-》默认构造创建临时值-》复制构造复制到每一个元素//如果不提供构造参数，全使用默认构造
		例如：
			vector<TestB> ta(10);//调用默认构造函数
    		vector<TestB> tb(10,6);//调用拷贝构造函数
	-- 数组元素：若没有提供类类型的元素初始化，则默认构造初始化每个元素，若使用花括号初始化列表，则先创建后复制。
		若定义了复制构造函数，也应该定义默认构造函数
拷贝赋值运算符：
	重载operate=函数，可以对赋值进行定义。
	-- 为类成员时，第一个操作数隐式绑定到this指针，右操作数一般为const引用传递。
	-- 返回值一般为类引用。
	复制构造函数和赋值操作符应一起出现。
	注意：
		· 如果将一个对象赋值给自身，赋值运算符必须能正常工作//不要上来就释放左侧对象
		· 大多数赋值运算符组合了析构函数和拷贝构造函数的工作
析构函数：
	析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的，逆序撤销每个非static成员。
	即使我们编写了自己的析构函数，合成析构函数仍然运行。自定义的析构函数执行完毕后，将运行合成析构函数以撤销类的成员。
	隐式销毁一个内置指针类型的成员不会delete他所指向的对象
	当对象的引用或指针超出作用域时，不会运行析构函数。只有删除指向动态分配对象的指针或实际对象超出作用域时，才会运行析构函数。
	--容器中的对象也是逆序析构。
阻止拷贝：
	定义删除的函数：//新标准
		NoCopy(const NoCopy&)=delete;//阻止拷贝
		NoCopy &operator=(const NoCopy&)=delete;//阻止赋值
	新标准之前：
		将拷贝构造函数和拷贝赋值运算符为private，类的友元和成员仍可复制。
		若声明但不定义则绝不能复制。通过声明（但不定义）private 复制构造函数，可以禁止任何复制类
		类型对象的尝试：用户代码中复制尝试将在编译时标记为错误，而成员函数和友元中的复制尝试将在链接时导致错误。
在赋值运算符中使用swap：
	H& H::operator=(H rhs)//参数非引用！！！
	{
		swap(*this,rhs);
		return *this;
	}
	使用swap将本对象和rhs交换，当赋值运算符结束后，rhs被销毁
	他自动处理了自赋值情况且天然就是异常安全的
	//由于参数非引用，当调用时先将对象拷贝到rhs中，如果失败，this不会变;如果成功，旧对象保存到rhs中，
	//退出函数时，由于局部对象超出作用域自动释放！！！
指针成员：
	复制指针时只复制指针中的地址，而不会复制指针指向的对象。
	管理指针常用的三种方法：
	1.指针成员采取常规指针性行为。这样的类具有指针的所有缺陷但无需特殊的复制控制。
	2.类可以实现所谓的智能指针行为。所指对象共享，但类能够防止悬垂指针。
	3.类采取值型行为。指针所指对象唯一，由每个类对象独立管理。复制时得到新副本，例如String类。
重载操作符：
	必须具有至少一个类类型或枚举类型的操作数。这条规则强制重载操作符不能重新定义用于内置类型对象的操作符！。
	不再具备短路求值特性。所以重载 &&、|| 或逗号操作符不是一种好的做法。
	将要用作关联容器键类型的类应定义 < 操作符。关联容器默认使用键类型的 < 操作符。即使该类型将只存储在顺序容器中，类通常也应该定义
	相等（==）和小于（<）操作符，理由是许多算法假定这个操作符存在。
	除了函数调用操作符operator()之外，重载操作符时使用默认实参是非法的。
	复合赋值(+=)返回对左操作数的引用，加操作符返回一个对象(为与内置操作符保持一致)//类重载了+运算符，还需要重载+=运算符，才能使用+=
	赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）等操作符必须定义为成员，将这些操作符定义为非成员函数将在编译时标记为错误。
	? 像赋值一样，复合赋值操作符通常应定义为类的成员，与赋值不同的是，不一定非得这样做， 如果定义非成员复合赋值操作符， 不会出现编译错误。
	? 改变对象状态或与给定类型紧密联系的其他一些操作符，如自增、自减和解引用，通常就定义为类成员。
	? 对称的操作符，如算术操作符、相等操作符、关系操作符和位操作符，最好定义为普通非成员函数。
	输出操作符不应该输出换行符，细节应该交由用户控制
	IO操作符必须为非成员函数：
		否则，左操作数只能是该类类型的对象，例：item<<cout;
		通常设置为友元。
		非常量输入输出对象：因为流会改变状态
		引用：因为无法直接创建或复制一个输出流对象。
		输入时可能发生错误，此时应把对象重置为默认状态，确保对象处于正确的状态
	重载输出输入操作符：
	friend ostream& operator<<(ostream&, const WordCount&);
		//参数和返回值都是引用！！！，ostream不允许创建对象，也不允许复制对象,也不能是const引用，因为读写会改变流状态
	friend istream& operator>>( istream&, WordCount& );
		//参数和返回值都是引用！！！，istream不允许创建对象，也不允许复制对象,也不能是const引用，因为读写会改变流状态
	要输出的参数常设置为const引用。
	要输入的参数必须为非const，因为要读到该对象中。
		输入操作符必须处理错误和文件结束的可能性。if(cin) .. else 复位(默认构造)！！！
	赋值操作符可以重载，必须定义为成员函数，必须返回对*this的引用。	
	下标操作符定义时，必须是成员函数，一般需要两个版本：一个为非const成员并返回引用，一个为const成员返回const引用。
	自增/自减运算符：
		前缀式运算符应该返回递增或递减后对象的引用。
		后缀式运算符应该返回递增或递减前的对象，是一个值而不是引用。
		后缀式操作符函数接受一个额外的int型形参。
		应该被定义为成员函数
	函数调用操作符：
		bool operator(const string&s){return s.size()>=this->size}
		必须声明为成员函数。可重载。定义此成员函数的对象称为函数对象。
		标准库定义了一些函数对象，常用来替代算法中的默认运算符。
		函数对象的函数适配器：
			绑定器：将一个操作数绑定给定值而将二元函数对象转换为一元函数对象。
				bind1st和bind2nd：例：count_if(v.begin(),v.end(),
										bind2nd(less_equal<int>(),10);
			求反器：将谓词函数对象的真值求反。
				not1和not2：not1将一元函数对象的真值求反，not2将二元函数对象的真值求反。
				例：count_if(v.begin(),v.end(),
								not1(bind2nd(less_equal<int>(),10);
自定义类的转换：例
	类成员转换函数：operator int() { return value; }
	//在转换函数的声明中 关键字 operator 后面的名字不一定必须是内置类型的名字 
	当使用  c=MyClass+3.14时，自动运用转换将其转换为int 3，再提升为3.0与3.14相加得到double类型值6.14
	转换函数采用如下的一般形式
	operator type();
	这里的 type 可用内置类型 类类型或 typedef 名取代 但是不允许 type 表示数组或函数
	类型 转换函数必须是成员函数 它的声明不能指定返回类型和参数表 
面向对象基本概念：数据抽象、继承、动态绑定
	虚函数：基类希望派生类重写的函数应定义为virtual，希望被继承的函数不能被定义为虚函数。
			非static成员函数。
			派生类必须对想要重定义的每个继承成员进行声明。
			声明必须与基类中的定义方式完全匹配，一个例外：返回对基类的引用或指针的虚函数，
				派生类中的虚函数可以返回基类函数所返回类型的派生类的引用或指针。
			加上域操作符可以强制调用虚函数的特定版本。
			派生类虚函数调用基类版本时，必须显式使用作用域操作符，否则，函数调用会在运行时确定并且是一个自身调用，导致无穷递归。
	动态绑定：使用继承层次中的任意对象，运行时指定，通过基类的引用或指针调用虚函数时发生。
			使用条件：1.只有虚函数成员才能进行动态绑定。
					  2.必须通过基类类型的引用或指针进行函数调用。	
	protected成员：定义派生类时可以使用，派生类对象不能直接访问，可调用派生类的成员函数访问。
	派生类可以进一步限制基类的访问权限，但不能放松权限，无论什么访问标号，直接派生类
		对基类成员有相同的访问权限。(即使是private继承，直接派生类还是可以访问直接基类的保护成员)
		派生类访问标号控制派生类的用户对从基类继承而来的成员的访问。
	友元关系不能继承。
改变个别成员的可访问性：
	using 基类::成员;//派生类只能为它可以访问的名字提供using声明
转换与继承：
	转换要考虑派生列表中的访问标号。
	派生类对象转换为基类类型的引用：
		派生类对象的地址可以对基类类型的指针进行赋值或者初始化，可以使用派生类类型的引用或对象初始化基类类型的引用。
	派生类对象对基类对象进行初始化或赋值：
		将派生类传给希望接受基类类型对象的函数时，派生类的基类部分被复制到形参，其余部分被切掉。
派生类构造函数：
	合成的派生类默认构造函数：
		1.调用基类的默认构造函数，初始化基类部分
		2.用常规变量初始化派生类部分，即未初始化。
	派生类构造函数的初始化列表只能初始化派生类的成员，不能直接初始化继承成员。相反派生类构造函数通过将基类包含在构造函数初始化列表中
	来间接初始化继承成员。
继承与复制：
	只含有类类型或内置类型数据成员、不含指针的类一般可以使用合成操作，
	具有指针成员的类一般需要定义自己的复制控制来管理这些成员。
	如果派生类定义了自己的复制构造函数，该复制构造函数一般显式使用基类复制构造
		函数初始化对象的基类部分。
	派生类赋值操作符同上：
		且赋值操作符必须防止自身复制：if(this!=&rhs){再操作};
	派生类析构函数;
		不负责撤销基类部分的成员，编译器显式调用派生类对象基类部分的析构函数。
		首先运行派生类析构函数，再运行基类析构函数。
	防止继承：
		C++11：在类名后跟上一个关键字final
默认构造函数何时自动生成：
	1.类中含有类对象
	2.基类默认构造函数
	3.虚函数
	4.虚基类
	编译器需要时才自动合成，并且需要时还可以扩张已经定义的构造函数
	如果类没有定义构造函数，那也不一定会合成默认构造函数
	编译器合成的默认构造函数不会初始化类中的非静态成员，只会初始化基类对象和成员类对象
继承与类作用域：{基类{派生类}}
	如果不能在派生类作用域中确定名字，就在外围基类作用域中查找该名字的定义。
	名字查找在编译时发生。
	基类类型的指针引用或对象只能访问对象的基类部分。或派生类的虚函数（run time）
	如果派生类重定义了重载成员，则通过派生类只能访问派生类中重定义的那些成员。
	如果派生类想通过自身类型使用的重载版本，则派生类必须要么重定义所有重载版本，要么
		一个也不定义。可以使用using声明将函数的所有重载实例加到派生类的作用域。
		然后只需要重定义本类型确实需要的重载版本即可，其他版本使用继承的定义。
子类初始化基类：
	对基类对象进行初始化或赋值，实际上是在调用函数：初始化时调用构造函数，赋值时调用赋值操作符。
	用派生类对象对基类对象进行初始化或赋值时，有两种可能性。第一种（虽然不太可能的）可能性是，基类可能显式定义了
		将派生类型对象复制或赋值给基类对象的含义，这可以通过定义适当的构造函数或赋值操作符实现
	另一种情况，基类通常定义了自己的复制构造和赋值操作符，则派生类初始化或赋值基类时，派生部分会被切掉。
派生类到基类的可访问性：
	如果是 public 继承，则用户代码和后代类都可以使用派生类到基类的转换。如果类是使用 private 或 protected 继承派生的，
	则用户代码不能将派生类型对象转换为基类对象。如果是 private 继承，则从 private 继承类派生的类不能转换为基类。
	如果是 protected 继承，则后续派生类的成员可以转换为基类类型。
	无论是什么派生访问标号，派生类本身都可以访问基类的 public 成员，因此，派生类本身的成员和友元总是可以访问派生类到基类的转换。
派生类初始化：
	派生类不能直接初始化基类的成员，需要在在初始化列表中调用基类的构造函数，派生类只能初始化直接基类。(即派生列表中指定的父类)
派生类复制赋值构造析构控制：
	如果派生类定义了自己的复制构造函数，该复制构造函数一般应显式使用基类复制构造函数初始化对象的基类部分。
	派生类使用合成版本，则会自动调用基类的复制构造函数初始化对象的基类部分。
	赋值操作符通常与复制构造函数类似：如果派生类定义了自己的赋值操作符，则该操作符必须对基类部分进行显式赋值。
	析构函数的工作与复制构造函数和赋值操作符不同：派生类析构函数不负责撤销基类对象的成员。
	编译器总是显式调用派生类对象基类部分的析构函数。每个析构函数只负责清除自己的成员。
	如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本。
构造函数和析构函数中的虚函数问题：
	派生类构造过程中和派生类析构过程中，对象是不完整的。编译器将对象的类型视为
		在此期间发生了变化，将派生类对象当作基类类型对象对待。
		如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本。
		//即基类调用基类的虚函数，派生类调用派生类的虚函数
纯虚函数：
	在虚函数形参表后面写上 =0 以指定纯虚函数，无需定义，若要定义只能在类的外部，该函数为后代类型提供了可以覆盖的接口，
	但这个类中绝对不会调用，最重要的是用户不能创建含有纯虚函数的类（抽象基类）的对象。
虚函数的默认实参：
	谁调用就用谁的默认实参，但最好将其默认实参值设为相同的
句柄类：定义包装
	句柄类存储和管理基类指针，指针所指对象的类型可以变化，它既可以指向基类类型对象又可以
		指向派生类对象。用户通过句柄类访问继承层次的操作，因为句柄类使用指针执行操作，
		虚成员的行为将在运行时根据句柄实际绑定的类型而变化，因此，句柄类的用户可以获
		得动态行为但无需操心指针的管理。
	像对任何保存指针的类一样，必须确定对复制控制做些什么。句柄类通常表现得像一个智能指针
		或者像一个值。
	句柄类决定句柄接口屏蔽还是不屏蔽继承层次。
模板：
	定义模板函数:template<typename T> [inline] T min(const T&,const T&);
	定义类模板：template<typename T> class 类名{};
	模板定义中，模板参数列表不能为空
	同一模板的声明和定义中，模板形参的名字不必相同。
	每个非类型形参前面必须带上类型名字。<typename T,L>//error
函数模板与类模板：
	调用函数模板，不必指定模板类型 			func(1,2)
	使用类模板时，必须为模板形参显式指定实参vector<int> a;
tuple：
	快速而随意的数据结构
	auto item = make_tuple("09-123",3,20.00,"面向对象");
	auto book = get<0>(item);//返回第一个成员
bitset:
	bitset<32> bit(1U);//32位，低位为1，其他位为0
	bitset<32> b1   
		转换为字符串：to_string()     
		转换为无符号长整型：to_ulong()
流随机访问：
	istream和ostream不支持随机访问，fstream和sstream支持
	tellg();		返回一个输入流的当前位置
	tellp();		返回一个输出流的当前位置
	seekg();		在输入流中将标记重定位到给定的绝对地址
	seekp();		在输出流中将标记重定位到给定的绝对地址
	seekp(off,from);在一个输出流中将标记定位到from之前或之后off个字符
	seekg(off,from);在一个输入流中将标记定位到from之前或之后off个字符
		from:	beg//偏移量相对于流开始位置
				cur//偏移量相对于流当前位置
				end//偏移量相对于流结尾位置
异常处理：
	异常类似于将实参传递给函数的方式抛出和捕获。可以传递给非引用形参的(意味着可以复制)
		不存在数组或函数类型的异常。相反，抛出一个数组，转换为指向数组首元素的指针，
		抛出一个函数，转换为指向该函数的指针。
	一般而言，在处理异常的时候，抛出异常的块中的局部存储不存在了。
		因为在处理异常的时候会释放局部存储，所以被抛出的对象就不能再局部存
		储，而是用 throw 表达式初始化一个称为异常对象的特殊对象。异常对象由编
		译器管理，而且保证驻留在可能被激活的任意 catch 都可以访问的空间。这个
		对象由 throw 创建，并被初始化为被抛出的表达式的副本。异常对象将传给对
		应的 catch，并且在完全处理了异常之后撤销。
	抛出指针通常是个坏主意：这要求在对应处理代码存在的任意地方存在指针所指向的对象。
栈展开：
	抛出异常--》暂停函数--》查找匹配的catch子句--》找不到--》调用函数退出--》继续去调用
		该函数的函数中查找。(嵌套函数调用链)。如果最终未找到匹配的catch，调用terminate函数。
	栈展开期间，提早退出包含throw的函数和调用链中可能的其他函数，编译器保证适当地
		撤销或析构局部对象。
	如果一个块直接分配资源，而且在释放资源之前发生异常，在栈展开期间将不会释放该资源。
	重新抛出异常：throw;
		单个catch不能完全处理一个异常时，通过重新抛出将异常传递给函数调用链中更上层的函数。
命名空间：
	可以在全局作用域或其他作用域内部定义，但不能在函数或类内部定义。
	命名空间作用域不能以分号结束。
	命名空间是累积的，可以分散到多个文件中。
	函数名完全限定，则处于命名空间的作用中，形参和函数体可以直接引用作用域内的成员。	
	未命名的名字空间：
		未命名的名字空间的定义局部于一个特定的文件 不能跨越多个文本文件
		可以不连续，不能使用域操作符引用，直接使用，如果在最外层作用域中定义，则未命名
		空间中的名字必须与全局作用域中定义的名字不同。
		如果头文件定义了未命名的命名空间，则每个包含该头文件的文件中，该空间定义不同的实体
	作用：
		声明局部于某个文件的实体
	未命名名字空间的成员与被声明为 static 的全局实体具有类似的特性。在 C 中 被声明为 static 
		的全局实体在声明它的文件之外是不可见的 。
	using声明：
		在声明作用域内可直接引用命名空间的成员
		只是声明一个名字，而非特定的函数
	内联命名空间：
		inline namespace outer{ namespace inner{} }
		通过外层命名空间可直接访问内层命名空间中的名字，无需再加前缀
多重继承下成员X：
	如果在每个路径中X表示同一虚基类成员，则没有二义性，因为共享该成员的单个实例。
	如果在某个路径中X是虚基类的成员，而在另一路径中X是后代派生类的成员，也没有二义性，
		因为特定派生类实例的优先级高于共享虚基类实例
	如果沿每个继承路径X表示后代派生类的不同成员，则该成员的直接访问是二义性的。
	解决二义性可以在本类中设计覆盖实例。
虚基类的构造：必然是首先构造虚基类
			ZOO
		/         \
	  BEAR     RACOON
		\          /
		   PANDA
	由最底层的派生类PANDA直接控制虚基类ZOO的构造。
	然后构造中间派生类BEAR，忽略中间派生类BEAR用于构造虚基类的初始化列表的初始化式
	然后构造RACOON,再次忽略ZOO的初始化式
	最后构造PANDA部分。
优化内存分配：
	new基于每个对象分配内存的事实可能会对某些类强加不可接受的运行时开销，可以通过预先
		分配用于创建新对象的内存，需要时在预先分配的内存中构造每个新对象。
operator new：库函数
	string * sp=new string("buzhidao");//此处new为运算符
	1.调用operator new的标准库函数，分配足够的内存-》
	2.运行构造函数，初始化-》
	3.返回该对象指针
operator delete：
	delete sp;//此处delete为运算符
	1.对sp指向的对象运行适当的析构函数
	2.调用operator delete标准库函数，释放该对象所用内存
定位new：
	接受指向已分配但未构造内存的指针，并在该内存中初始化一个对象
	new (p) T(t);
	定位new表达式：
	允许向new传递额外的参数
	int *p=new(nothrow) int;//分配失败返回空指针
运行时类型识别：RTTI
	typeid操作符：返回指针或引用所指对象的实际类型
	dynamic_cast操作符：将基类类型的指针或引用安全的转换为派生类型的指针或引用
	对于带虚函数的类，运行时执行RTTI操作符，对于其他类型，在编译时计算RTTI操作符
枚举：//枚举不能执行迭代，即++和--
	限定作用域：enum class e1{};//
		强类型枚举，使用时必须加上作用域e1
		不能自动转换为int等类型，需要强转或static_cast<T> 才行
	不限定作用域：enum e2{};
		被视为整数，不同枚举类型也能比较
嵌套类：
	只在外层类作用域可见，外层成员可以像使用其他类型成员一样使用嵌套类的名字
	是独立的类，嵌套类的对象不具备外围类所定义的成员，同样，外围类的成员也不具备
		嵌套类所定义的成员。
局部类：
	不能使用函数作用域中的局部变量
------------------NOTICE------------------------------------------------------------------
全局变量重定义或是多次定义的：
	定义时尽量在.cpp文件中进行，而不要在.h文件中定义，在.h文件中用extern关键字声明，
		否则可能会引起重复定义。
使用cl工具查看类的内存布局：
	1、开始菜单打开vs2017命令行工具(否则需要设置环境变量，费劲)
    2、cl /d1 reportSingleClassLayoutXXX  [filename]
    	其中XXX表示类名，[filename]表示类所在的.cpp文件路径
	
	


















