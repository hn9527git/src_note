七大原则：//开口里合最单依
	开闭原则
		对扩展开放，对修改关闭
	接口隔离原则：
		接口应该有专一性，使用者不应该依赖那些它不需要的接口
	里氏替换原则
		子类必须能够替换他们的父类
	合成复用原则
		尽量使用合成/聚合的方式，而不是使用继承
	迪米特法则原则
		最少知道原则，一个类对自己依赖的类知道的越少越好
	单一职责原则
		对于一个类而言，引起他变化的原因应该只有一个
	依赖倒转原则
		依赖接口，而不依赖具体实现，高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象

创建型模式：
	简单工厂模式（Factory Pattern）//不属于23设计模式
		用于在不同条件下创建不同的产品
		只需要知道产品的名称即可得到对象，封装了对象的创建细节，易于扩展
		每次增加一个产品时，都需要增加一个具体类和修改对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖
	工厂方法模式：
		在父类中提供一个创建对象的接口， 允许子类决定实例化对象的类型
		避免了创建者和对象的紧耦合，符合单一职责，开闭原则，添加新的对象不需要修改已有的工厂和客户端代码
	抽象工厂模式（Abstract Factory Pattern）
		它能创建一系列相关的对象， 而无需指定其具体类
		 你可以确保同一工厂生成的产品相互匹配。你可以避免客户端和具体产品代码的耦合。单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。
		由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂
	单例模式（Singleton Pattern）
		保证一个类仅有一个实例，并提供一个访问它的全局访问点
		在内存中只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁
		与单一职责冲突，一个类应该只关心内部逻辑，不必关心使用者怎么实例化
	建造者模式（Builder Pattern）
		将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
		建造者独立，易扩展，便于控制细节风险
		产品必须有共同点，如果内部变化复杂，会有很多的建造类
	原型模式（Prototype Pattern）
		能够复制对象， 甚至是复杂对象， 而又无需使代码依赖它们所属的具体类，降低耦合性
		性能提高，逃避构造函数的约束
		克隆包含循环引用的复杂对象可能会非常麻烦
		tips:原型模式和C++拷贝构造有什么不一样，是否可以替代原型模式？
			不可以，因为如果你仅有一个基类的指针对象，不知道实际指向哪一个派生类，拷贝构造函数不能复制出这个未知类型的对象
			而原型模式可以通过动态调用clone接口去复制这个未知具体类型的对象
结构型模式：
	适配器模式（Adapter Pattern）
		将一个类的接口转换成客户希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
		提高了类的复用，灵活性好
		过多地使用适配器会让系统非常零乱，不必要的话不要使用，直接重构
	桥接模式（Bridge Pattern）
		将抽象部分与它的实现部分分离，使它们都可以独立地变化
		抽象和实现的分离，扩展性好
		会增加系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程
	组合模式（Composite Pattern）
		将对象组合成树形结构以表示 部分-整体 的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性
		高层模块调用简单，节点自由添加
		叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则
	装饰器模式（Decorator Pattern）
		动态地给一个对象增加额外的职责，就增加功能来说，装饰模式比生成子类更灵活
		装饰类和被装饰类可以独立发展，不会相互耦合，可以动态扩展一个类的功能
		装饰类会过多膨胀，而且看起来很相似不易于查错
	外观模式（Facade Pattern）
		为子系统中的一组接口提供一个一致的界面，此模式定义一个高层接口，这个接口使得这一子系统更加容易使用
		你可以让自己的代码独立于复杂子系统。
 		外观可能成为与程序中所有类都耦合的上帝对象。
	享元模式（Flyweight Pattern）
		摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。
		如果程序中有很多相似对象， 那么你将可以节省大量内存
		你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据;代码会变得更加复杂。 团队中的新成员总是会问 “为什么要像这样拆分一个实体的状态？”
	代理模式（Proxy Pattern）
		为其他对象提供一种代理以控制对这个对象的访问
		职责清晰，高扩展性，智能化
		用户和真实对象之间增加了代理对象，可能导致访问处理变慢，实现代理模式需要额外的工作，有些比较复杂
行为型模式：
	责任链模式（Chain of Responsibility Pattern）
		使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止
		接收者和发送者都没有对方的明确信息，链中的对象自己也不知道链的结构，可以简化对象的相互链接，仅需保持一个指向其后继者的引用，可以灵活的配置责任传递链
		不能保证请求一定被处理，系统性能受影响，调试不方便，可能导致循环引用
	命令模式（Command Pattern）
		将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作
		支持命令队列，可以记入日志，接收方可以决定是否接受命令，容易实现撤销和重做，新加的具体命令类不影响其他类，将请求对象与实际操作对象分离
		使用命令模式可能会导致系统中有过多的具体命令类
	迭代器模式（Iterator Pattern）
		提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示
		支持以不同的方式遍历一个聚合对象，分离了便利行为，可以不暴露集合内部结构，又可以让代码透明地访问集合内部的数据
		每一个聚合类都需要对应的新的迭代器类，类的个数在增加，这在一定程度上增加了系统的复杂性
	中介者模式（Mediator Pattern）
		用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互
		降低了类的复杂度，将一对多转换为一对一，多个类的解耦，符合迪米特法则
		类的增多会导致中介者庞大，变得复杂难以维护
	备忘录模式（Memento Pattern）
		在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到原先保存的状态
		提供可恢复的机制，实现了信息的封装，用户不必关心保存细节
		如果类的成员变量过多，或多次保存，会占用太多资源
	观察者模式（Observer Pattern）
		一个对象的状态发生变化，所有的观察者对象都将得到通知
		开闭原则，可在运行时建立对象之间的联系
		如果有很多观察者时，通知所有的观察者会花费很多时间。如果观察者和目标对象之间有循环依赖的话，可能导致系统崩溃，通知顺序随机
	状态模式（State Pattern）
		当一个对象的内在状态改变时允许改变其行为，当控制一个对象状态转换的条件表达式过于复杂时，把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化
		封装了转换规则，避免大量的判断逻辑
		使得类和对象的个数增多，实现比较复杂，违反开闭原则
	策略模式（Strategy Pattern）
		有多个类，但其主要区别是他们的行为不同
		避免了多重条件判断，算法可以自由切换，扩展性好
		策略类会膨胀，所有的策略类都需要对外暴露
	模板模式（Template Pattern）
		定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法可以不改变一个算法的结构即可重定义算法中的某些特定步骤

	访问者模式（Visitor Pattern）
		可以在不改变各个元素的类的前提下定义作用于这些元素的新操作
		单一职责：可以将相同行为的不同版本移到同一个类中。开闭原则：可以给对象定义新的操作，而不需要修改对象本身
		增删元素类时需要修改每一个访问者，无法访问私有变量
		补充：
			C++不支持双分派，仅支持单分派，实现双分派需要在第一次分派的重载函数里通过静态参数再次分派自己，即两次动态绑定
			例如：A.Accept(B) {
				B.Visit(this);
			}

