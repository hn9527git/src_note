makefile杂记
$@，$^，$<代表的意义分别是： 
	$@ 当前目标文件，
	$^ 所有的依赖文件，
	$< 第一个依赖文件。
tuxedo中遇到修改头文件不编译问题解决：
	make -f Makefile.new clean
	make -f Makefile.new install
	make -f Makefile.new all
make
	根据Makefile文件编译源代码、连接、生成目标文件、可执行文件。
make clean
	清除上次的make命令所产生的object文件（后缀为“.o”的文件）及可执行文件。
make install
	将编译成功的可执行文件安装到系统目录中，一般为/usr/local/bin目录。
make dist
	产生发布软件包文件（即distribution package）。这个命令将会将可执行文件及
	相关文件打包成一个tar.gz压缩的文件用来作为发布软件的软件包。
	它会在当前目录下生成一个名字类似“PACKAGE-VERSION.tar.gz”的文件。
	PACKAGE和VERSION,是我们在configure.in中定义的AM_INIT_AUTOMAKE（PACKAGE, VERSION）。
make distcheck
	生成发布软件包并对其进行测试检查，以确定发布包的正确性。这个操作将自动把压缩包文件解开，
	然后执行configure命令，并且执行make,来确认编译不出现错误，最后提示你软件包已经准备好，
	可以发布了。
make distclean
	类似make clean,但同时也将configure生成的文件全部删除掉，包括Makefile文件。
make时重新编译：
	1. 所有的源文件没有被编译过，则对各个 C 源文件进行编译并进行链接，生成最
		后的可执行程序；源文件进行编译并进行链接，生成最后的可执行程序；
	2. 每一个在上次执行 make 之后修改过的 C 源代码文件在本次执行 make 时将会
		被重新编译；时将会被重新编译；
	3. 头文件在上一次执行 make 之后被修改。则所有包含此头文件的 C 源文件在本
		次执行源文件在本次执行 make 时将会被重新编译。
target...:依赖文件//终极目标：所需依赖目标文件名称
	命令行
	...//依赖文件生成过程
.PHONY:clean//将clean目标声明为伪目标，避免磁盘上存在一个clean文件时，clean命令行无法执行
	clean:
		-rm *.o//加上-，表示忽略rm命令的执行错误信息
	· 每个命令行必须以【tab】字符开始
	· make后删除中间文件只需执行 make clean
.o文件的处理：
	1. 目标.o 文件不存在，使用其描述规则创建它；
	2. 目标.o 文件存在，目标.o 文件所依赖的.c 源文件、.h 文件中的任何一个比目标.o
	   文件“更新”（在上一次 make 之后被修改）。则根据规则重新编译生成它；
	3. 目标.o 文件存在，目标.o 文件比它的任何一个依赖文件（的.c 源文件、.h 文件）
	   “更新”（它的依赖文件在上一次 make 之后没有被修改），则什么也不做
终极目标的处理：
	1. 目标文件“edit”不存在，则执行规则以创建目标“edit”。
	2. 目标文件“edit”存在，其依赖文件中有一个或者多个文件比它“更新”，则根
	   据规则重新链接生成“edit”。
	3. 目标文件“edit”存在，它比它的任何一个依赖文件都“更新”，则什么也不做。
指定变量：
	用变量替代大量的依赖文件列表，便于修改(只需修改一处)
	定义：object=x.o xx.o xxx.o ...
	使用：$(object)
自动推导：即隐含规则
	make会自动为xxx.o文件寻找合适的依赖文件(如：xxx.cpp)
	命令行可以简化为：xxx.o:xxx.h xx.h(只写头文件即可)
完整makefile包括：
	· 显式规则、
		描述在何种情况下如何更新一个或多个目标文件
	· 隐式规则、
		make根据目标文件名自动搜索依赖文件并使用默认命令更新
	· 变量定义、
		使用一个字符或字符串代表一段文本
	· 指示符、
		指明在make程序读取makefile文件过程中所要执行的动作
	· 注释
		#开头为注释
make查找执行文件顺序：
	GUNmakefile(仅GUN make识别)  makefile  Makefile(推荐)
	也可以直接指定文件：
		make f file_name
包含其他makefile文件：
	incluide file_name//可以使用通配符，勿tab开头
	· 它告诉make暂停读取当前的makefile，转而去读取include指定的一个或多个文件，完成后再继续当前
	   makefile的读取
	file_name搜索顺序：
		绝对路径-> -I指定 -> /usr/gnu/include -> /usr/local/include -> /usr/include
	-include file_name:可以忽略包含文件过程中的错误
变量MAKEFILES://不推荐使用，移植混乱，推荐使用include
	· 如果当前环境定义了该变量，make执行时首先将此变量的值作为需要读入的Makefile文件，
	  类似include
	  区别：
	  	1.make不会将其目标作为终极目标，如果目录下无make执行文件 同样出错 
	  	2.如果不能找到环境变量定义的文件列表文件，不出错
	  	3.首先读取，include是定义处读取
变量MAKEFILE_LIST：
	make读取的文件名将被自动追加到该变量的定义域中
特殊变量.VARIABLES：
	展开后为此引用点之前、makefile文件中所定义的所有全局变量列表，包括：
		空变量、内嵌变量，不包括目标指定的变量
makefile文件的重建：
	· make 在读入所有 makefile 文件之后，首先将所读取的每个 makefile 作为一个目
	  标，寻找更新它们的规则。如果存在一个更新某一个 makefile 文件明确规则或者隐含
	  规则，就去更新对应的 makefile 文件。完成对所有的 makefile 文件的更新之后，如果
	  之前所读取任何一个 makefile 文件被更新，那么 make 就清除本次执行的状态重新读
	  取一遍所有的 makefile 文件
	· 如果makefile不存在，可以通过一个规则创建，则make自动创建，之后重新读取并开始执行
	· 一个存在（缺省命名的或者可被创建的）的 makefile 文件并不是 make正确运行的前提
GUN make 的执行过程分为两个阶段。
	第一阶段：
		1.读取所有的 makefile 文件（包括“MAKIFILES”变量指定的、指示符
		2.“include”指定的、以及命令行选项“-f(--file)”指定的 makefile 文件），
		3.内建所有的变量、
		4.明确规则和隐含规则，并
		5.建立所有目标和依赖之间的依赖关系结构链表。
	在第二阶段：
		6.根据第一阶段已经建立的依赖关系结构链表决定哪些目标需要更新，
		7.并使用对应的规则来重建这些目标。
	//第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，
	//如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。
objects = *.o
    上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。Makefile中的变量其实就是
    C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：
    objects := $(wildcard *.o)
	这种用法由关键字“wildcard”指出
源文件搜寻：
	在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。
	Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。
	    VPATH = src:../headers
	上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）
	另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的
	那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：
	    1、vpath <pattern> <directories>
	    为符合模式<pattern>的文件指定搜索目录<directories>。
	    2、vpath <pattern>
	    清除符合模式<pattern>的文件的搜索目录。
	    3、vpath
	    清除所有已被设置好了的文件搜索目录。
	vapth使用方法中的<pattern>需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。
	<pattern>指定了要搜索的文件集，而<directories>则指定了<pattern>的文件集的搜索的目录。例如：
	    vpath %.h ../headers
	该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）
	我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的<pattern>，或是被重复了的<pattern>，那么，make会按照vpath语句的先后顺序来执行搜索。如：
	    vpath %.c foo
	    vpath %   blish
	    vpath %.c bar
	其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。
	    vpath %.c foo:bar
	    vpath %   blish
	而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。
